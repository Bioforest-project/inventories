---
title: "Data aggregation"
format:
  pdf:
    toc: true
    number-sections: true
    colorlinks: true
    fig-pos: "H"
params: 
  site: saonicolau
  taper: false
  harmonise_area: true
  print: true

execute:
  echo: false      
---

```{r setup, include=FALSE}
knitr::opts_knit$set(
  root.dir = rprojroot::find_rstudio_root_file(),
  warning = FALSE, message = FALSE, results = "hide"
)

library(data.table)
library(BIOMASS)
library(ggplot2)
library(tidyverse)
library(entropart)
library(fundiversity)
library(patchwork)
library(readxl)
library(terra)
```

# Introduction

This document is intended for data contributors to the Bioforest project, an initiative of the TmFO network.

There are 2 ways to view this document: 

1. You are viewing the PDF already generated for a dataset
2. You have access to the Quarto script, which needs to be run with R in order to generate visual outputs or render a PDF.

## If you are viewing this document as a PDF :

This document will help you visualize various aspects of your data, understand the applied data correction steps, and generate an aggregated dataset. This aggregated data set (depending on the variables available) will be used for analysis by various working groups in the Bioforest project. It also facilitates feedback from Site PIs regarding any necessary changes to corrections and aggregations. We encourage every Site PI to carefully review this document and provide feedback.

## If you are running the Quarto script (ignore this section if you are viewing the PDF):

This script will take you through various aspects of your data, understand the applied data correction steps, visualize each step, and generate an aggregated dataset. This aggregated data set (depending on the variables available) will be used for analysis by various working groups in the Bioforest project. It also facilitates feedback from Site PIs regarding any necessary changes to corrections and aggregations. We encourage every Site PI to carefully review this document and provide feedback.

Before running the Quarto script, please complete the following checklist and ensure your dataset is correctly named and structured.

You should have already:

-   Signed the [data agreement](https://drive.google.com/file/d/1xxeE1FkkTzfnTS7iRFf3vOaOS4FclL82/view?usp=drive_link)- please ask for access to the link if you don't have it;

-   Harmonized your **raw** dataset using the [DataHarmonization app](https://github.com/Alliance-for-Tropical-Forest-Science/DataHarmonization); the harmonized dataset should be placed in the same folder as this file;

-   Provided your species list;

-   Added plot-level information to this [document](https://docs.google.com/spreadsheets/d/1fq2owxMBLBwwibcdw2uQQFxnIhsMbaH4Qcj_xUwVvSQ/edit?usp=drive_link) with the same plot names as in your dataset;

-   Requested the necessary files to run this script, including taxonomic corrections and functional traits;

-   Placed all required input files in the same folder;

-   Named your file as: harmonized_data_site-name_versionname.csv

Note: Ensure that the character strings used in your harmonized file name exactly match those in the params section at the beginning of this file.

```{r get-plot-level-data}
#| message: false
#| warning: false
# download from google drive
path_metadata <- "data/raw_data/bioforest-plot-information.csv"
if (!file.exists(path_metadata)) {
  "1fq2owxMBLBwwibcdw2uQQFxnIhsMbaH4Qcj_xUwVvSQ" |>
    googledrive::as_id() |>
    googledrive::drive_get() |>
    googledrive::drive_download(
      path = "data/raw_data/bioforest-plot-information.xlsx",
      overwrite = TRUE
    )

  sites <- "data/raw_data/bioforest-plot-information.xlsx" |>
    read_excel(sheet = "site_name_correction") |>
    separate_rows(site_raw, sep = ",") |>
    unique()
  write.csv(sites, file = "data/raw_data/sites.csv")

  # clean plot information
  "data/raw_data/bioforest-plot-information.xlsx" |>
    read_excel(sheet = "Sheet1") |>
    # change site name to correspond to raw data
    mutate(site = as.character(site)) |>
    rename(site_raw = site) |>
    left_join(sites) |>
    select(-site_raw) |>
    # remove "subplot" from Tene data
    mutate(plot = gsub("Subplot_", "", plot)) |>
    # add E variable for AGB allometry (from Chave et al 2014)
    mutate(e = extract(rast(cacheManager("E.bil")),
             cbind(longitude, latitude),
             method = "bilinear"
           )$E) |>
    write.csv(path_metadata, row.names = FALSE)
}
```


```{r load-data}
#| message: false
#| warning: false
# automate compilation for all sites with qmd params
data_list <- list.files("data/raw_data/", params$site, full.names = TRUE)
if (length(data_list) == 0) {
  stop("Please check that the site name in params matches your data file name.")
}

# creating a taxonomic ID to use for joining wrong and corrected taxa
read_harmonized <- function(file) {
  cols <- c(
    ScientificName = NA_character_,
    VernName = NA_character_,
    Family = NA_character_,
    Genus = NA_character_,
    Species = NA_character_
  )
  read_csv(file,
    locale = readr::locale(encoding = "latin1"),
    col_types = cols()
  ) %>%
    add_column(!!!cols[!names(cols) %in% names(.)]) %>%
    mutate(raw_taxonomy = paste(
      ScientificName, "-", VernName, "-",
      Family, Genus, Species
    )) %>%
    mutate(file = gsub("data/raw_data/", "", file))
}

# extracting data file and creating consistent site names
data_raw <- data_list |>
  lapply(read_harmonized) |>
  bind_rows() |>
  mutate(site_raw = as.character(Site)) |>
  select(-Site) |>
  left_join(read.csv("data/raw_data/sites.csv")) |>
  rename(Site = site) |>
  select(-site_raw) |>
  mutate(Plot = as.character(Plot))
```

```{r create-data-cor}
#| message: false
#| warning: false
data_cor <- data_raw
```

```{r merge-cleaned-taxonomy}
#| message: false
#| warning: false
data_species <-
  read_tsv("data/derived_data/taxonomy_v6.tsv") |>
  select(contains("cleaned") | "raw_taxonomy") |>
  unique()

data_cor <- data_cor |>
  left_join(data_species, by = c("raw_taxonomy"))
```

```{r temp-complete-species}
if (any(data_raw$Site %in% c("Uppangala", "Sao Nicolau"))) {
  data_species_complete <- read_tsv("data/derived_data/taxonomy_v6.tsv") |>
    select(genus_raw, species_raw, contains("cleaned")) |>
    subset(!is.na(species_cleaned)) |>
    unique()
  colnames(data_species_complete) <- gsub(
    "cleaned", "complete",
    colnames(data_species_complete)
  )
  data_cor <- data_cor |>
    separate(ScientificName, c("genus_sn", "species_sn"),
      extra = "drop", remove = FALSE
    ) |>
    left_join(data_species_complete,
      by = join_by(genus_sn == genus_raw, species_sn == species_raw)
    ) |>
    mutate(
      scientific_cleaned = ifelse(
        is.na(species_cleaned) & !is.na(species_complete),
        scientific_complete, scientific_cleaned
      )
    ) |>
    mutate(
      species_cleaned = ifelse(
        is.na(species_cleaned) & !is.na(species_complete),
        species_complete, species_cleaned
      )
    ) |>
    select(!contains("_complete") & !contains("_sn"))
}
```

```{r complete-plotarea-data}
#| message: false
#| warning: false
# add site if missing
data_cor <- data_cor |>
  mutate(Site = ifelse(is.na(Site), names(sort(table(data_raw$Site)))[1], Site))

# add missing plot area
plot_area <- data_cor |>
  select(Site, Plot, PlotArea) |>
  drop_na() |>
  rename(PlotAreaUnique = PlotArea) |>
  unique()

if (any(duplicated(with(plot_area, paste(Site, Plot))))) {
  stop(paste(
    "The plot area information in your data is inconsistent:",
    "some plots have different values."
  ))
}

data_cor <- data_cor |>
  left_join(plot_area, by = c("Site", "Plot")) |>
  mutate(PlotArea = ifelse(!is.na(PlotAreaUnique), PlotAreaUnique, PlotArea)) |>
  select(-PlotAreaUnique)

if (any(is.na(data_cor$PlotArea))) {
  stop(paste("Some plots are missing PlotArea values."))
}

# avoid absurd PlotArea values
data_cor <- data_cor |>
  mutate(PlotArea = ifelse(grepl("Tapajos", Site), 0.25, PlotArea))

if (any(data_cor$PlotArea <= 0)) {
  stop(paste("Some PlotArea values are zero or negative."))
}
if (any(data_cor$PlotArea > 100)) {
  stop(paste("Some PlotArea values are > 100 ha."))
}
```

```{r complete-other-data}
#| message: false
#| warning: false
# add census year information per plot
if (!"IdCensus" %in% colnames(data_cor)) {
  data_cor <- mutate(data_cor, IdCensus = as.character(Year))
}
data_cor <- data_cor |>
  select(Site, Plot, Year, IdCensus) |>
  drop_na() |>
  group_by(Site, Plot, IdCensus) |>
  summarise(year_census = median(Year)) |>
  right_join(data_cor) |>
  # add missing years
  mutate(Year = ifelse(is.na(Year), year_census, Year)) |>
  mutate(year_census = ifelse(is.na(year_census), Year, year_census))
```

```{r remove-values}
#| message: false
#| warning: false

# remove missing plots (warning is given later)
data_cor <- data_cor |>
  filter(!is.na(Plot))
data_cor <- data_cor |>
  # add UPA info in Mil
  mutate(Plot = ifelse(Site == "Mil", paste0("UPA_B_", Plot), Plot))

# some values (partial censuses, etc) need to be removed in some sites
text <- ""
if (any(data_cor$Site == "Paracou")) {
  data_cor <- data_cor |>
    subset(!(Site == "Paracou" & as.numeric(Plot) == 16)) |>
    subset(!(Site == "Paracou" & (Year %in% c(1996, 1998, 2000, 2002)))) |>
    subset(!(Site == "Paracou" & Year == 2010 & Plot == 15))
  text <- paste(
    text,
    "In Paracou, we removed partial census years: 1996, 1998, 2000, and 2002,",
    "and census year 2010 of plot 15 (25% of the plot was not measured)."
  )
}
if (any(data_cor$Site == "Malinau")) {
  data_cor <- data_cor |>
    subset(!(Site == "Malinau" & Year == 2012))
  text <- paste(
    text,
    "In Malinau, we removed the census of 2012 as discussed with the PI"
  )
}
if (any(data_cor$Site == "BAFOG")) {
  data_cor <- data_cor |>
    subset(!(Site == "BAFOG" & (Plot %in% c("VI", "VII"))))
  text <- paste(
    text,
    "In BAFOG, we removed all the censuses for plots VI and VII",
    "(different protocol and less reliable)."
  )
}
```

`r text`


```{r join-plot-information}
#| message: false
#| warning: false

plot_information <- read.csv(path_metadata)
# plots that are not on the online document
data_missing <- data_cor |>
  mutate(site = Site, plot = Plot) |>
  select(site, plot) |>
  unique() |>
  merge(plot_information, all.x = TRUE) |>
  subset(is.na(longitude)) |>
  mutate(idplot = paste(site, plot, sep = "-"))
# for sao nicolau, get the treatment information in the file name and add it to
# the plot ID
data_cor <- data_cor |>
  mutate(Plot = ifelse(Site == "Sao Nicolau" & grepl("control", file),
    paste0(Plot, "-Control"), Plot
  )) |>
  mutate(Plot = ifelse(Site == "Sao Nicolau" & !grepl("control", file),
    paste0(Plot, "-Logging"), Plot
  ))

# add plot-level information to the table
data_cor <- data_cor |>
  merge(plot_information,
    by.x = c("Site", "Plot"), by.y = c("site", "plot"),
    all.x = TRUE
  )

# if no plots were found in the online document
if (all(is.na(data_cor$e))) {
  stop(paste0(
    "Please check the information (site name, plot names and coordinates) ",
    "on the online document: https://docs.google.com/spreadsheets/d/1fq2owxMBLBwwibcdw2uQQFxnIhsMbaH4Qcj_xUwVvSQ/edit?usp=drive_link" # nolint
  ))
}

# if some plots have coordinates but not all: use mean value of E for plots with
# missing coordinates
data_cor <- data_cor |>
  mutate(e = ifelse(is.na(e), mean(data_cor$e, na.rm = TRUE), e))

missing <- paste(subset(data_missing, is.na(longitude))$idplot, collapse = ", ")

text <- ifelse(
  nchar(missing) > 0,
  paste0(
    "The following plots in the dataset have missing coordinates: ", missing,
    ". We used the average value for variable E in other plots (E = ",
    round(mean(data_cor$e, na.rm = TRUE), 4), ")."
  ),
  "All plots in the dataset have coordinates."
)
```
`r text`


# General presentation of the data

This document presents the data aggregation for the `r paste(unique(data_cor$Site), collapse = ", ")` site, with `r length(unique(data_cor$Plot))` plots, measured between `r min(data_cor$Year)` and `r max(data_cor$Year)`.

`r text`

If needed, you can add any missing information to the [online document](https://docs.google.com/spreadsheets/d/1fq2owxMBLBwwibcdw2uQQFxnIhsMbaH4Qcj_xUwVvSQ/edit?usp=drive_link) or check that the site and plot names are consistent between your harmonized data and the online document.

The dataset has `r dim(data_cor)[1]` observations, belonging to `r length(unique(data_cor$IdStem))` stems including he following life forms: `r unique(data_cor$LifeForm)`.

## Summary of plots and censuses

The following table shows the number of censuses per plots, the first and last year of census. If you feel like the information is not accurate, please let us know.

```{r show-census-count}
#| message: false
#| warning: false
data_cor %>%
  group_by(Site, Plot) %>%
  summarise(
    number_of_censuses = length(unique(IdCensus)),
    first_census = min(Year),
    last_census = max(Year)
  ) %>%
  knitr::kable(col.names = c(
    "Site", "Plot", "Number of censuses",
    "First census", "Last census"
  ))
```

```{r}
text <- ""
if (any(is.na(data_raw$Plot))) {
  text <- data_raw |>
    filter(is.na(Plot)) |>
    summarise(n_distinct(IdTree)) |>
    paste("trees don't have a plot ID.")
}
```

`r text`

*Please let us know if there are missing plots or censuses.*

The following figures show the location of each plot as indicated by you in the [online document](https://docs.google.com/spreadsheets/d/1fq2owxMBLBwwibcdw2uQQFxnIhsMbaH4Qcj_xUwVvSQ/edit?usp=drive_link), as well as the censuses in which each plot was measured.

```{r maps-visual}
#| message: false
#| warning: false

if (params$print) {
  # Maps per plot and per census
  map <- data_cor |>
    select(Plot, longitude, latitude) |>
    unique() |>
    ggplot(aes(
      x = longitude, y = latitude,
      color = as.factor(Plot)
    )) +
    geom_point(alpha = 0.6, show.legend = FALSE) +
    # facet_wrap(~ Year) +
    labs(
      title = "Map of Plots",
      x = "Longitude",
      y = "Latitude",
      color = "Plot ID"
    ) +
    coord_equal() +
    theme_minimal()

  plots <- data_cor |>
    select(Plot, Year) |>
    unique() |>
    ggplot(aes(x = Year, y = Plot, color = as.factor(Plot))) +
    geom_point(alpha = 0.6, show.legend = FALSE) +
    scale_y_discrete(breaks = c(
      min(data_cor$Plot),
      median(data_cor$Plot),
      max(data_cor$Plot)
    )) +
    labs(
      title = "Plots censused across years",
      x = "Year",
      y = "Plot number",
      color = "Plot ID"
    ) +
    theme_minimal()

  (map + plots)
}
```

```{r split-large-plots}
#| message: false
#| warning: false
# cut plots >= 2 ha into smaller plots
# problem with manare: some trees were not located in the larger plots
# bafog: extrapolate missing tree coordinates based on average coordinates by
# 25x25m subplot
text <- ""
if (params$site == "bafog") {
  data_cor <- data_cor |>
    group_by(Plot, Subplot) |>
    mutate(
      Xsubplot = sum(range(XTreePlot, na.rm = TRUE)) / 2,
      Ysubplot = sum(range(YTreePlot, na.rm = TRUE)) / 2
    ) |>
    mutate(
      XTreePlot = ifelse(is.na(XTreePlot), Xsubplot, XTreePlot),
      YTreePlot = ifelse(is.na(YTreePlot), Ysubplot, YTreePlot)
    ) |>
    select(-Xsubplot, -Ysubplot) |>
    ungroup()
}
if (params$site %in% c("montagnetortue", "bafog") & params$harmonise_area) { # nolint
  size <- 100
  data_cor <- data_cor |>
    group_by(Plot) |>
    mutate(Plot = paste(
      Plot,
      as.numeric(cut(XTreePlot, seq(0, round(max(XTreePlot)), size))),
      as.numeric(cut(YTreePlot, seq(0, round(max(YTreePlot)), size))),
      sep = "_"
    )) |>
    mutate(PlotArea = 1) |>
    filter(!grepl("NA", Plot))

  text <- paste(
    "Because the plots are larger than 2 ha, we cut them into 4",
    "1-ha plots based on tree location in the plot."
  )
}
if (params$site %in% c("paracou", "mbaiki", "strek") & params$harmonise_area) { # nolint
  data_cor <- data_cor |>
    mutate(Plot = paste(Plot, Subplot, sep = "_")) |>
    mutate(PlotArea = SubplotArea)
  text <- paste(
    "Because the plots are larger than 2 ha, we cut them into 4",
    "smaller plots based on subplot information."
  )
}
```

```{r group-small-plots}
data_cor <- "data/raw_data/plot_junction.csv" |>
  readr::read_csv(col_types = "cccd") |>
  right_join(data_cor) |>
  mutate(
    Plot = ifelse(!is.na(new_plot), new_plot, Plot),
    PlotArea = ifelse(!is.na(new_plot), new_plot_area, PlotArea)
  ) |>
  select(-new_plot, -new_plot_area)
```

`r text`

## Taxonomic identification

The taxonomic identification resolution of each site is different, so we try to identify this level, and ensure that it is not what is far from expected.

Most sites have separate columns with the species vernacular names, and scientific names. For the purpose of this project, we hope to extract maximum possible information using both names. However, we only use scientific names further in this document.

```{r}
#| warning: false
# add scientific names of unidentified stems based on vernacular names
# (only for French Guiana sites)

if (params$site %in% c("paracou", "montagnetortue", "bafog", "manare")) {
  vern <- data_cor |>
    select(VernName, scientific_cleaned) |>
    drop_na() |>
    subset(VernName != "-" &
      !str_detect(substr(VernName, 1, 1), "[[:upper:]]")) |> # nolint
    group_by(VernName) |>
    summarise(scientific_vern = names(
      sort(table(scientific_cleaned), decreasing = TRUE)
    )[1]) |>
    separate(scientific_vern, c("genus_vern", "species_vern"), remove = FALSE)

  data_cor <- merge(data_cor, vern, all.x = TRUE)
  data_cor <- data_cor |>
    mutate(scientific_cleaned = ifelse(
      is.na(scientific_cleaned),
      scientific_vern,
      scientific_cleaned
    )) |>
    mutate(genus_cleaned = ifelse(
      is.na(genus_cleaned),
      genus_vern,
      genus_cleaned
    )) |>
    mutate(species_cleaned = ifelse(
      is.na(species_cleaned),
      species_vern,
      species_cleaned
    ))

  text <- paste(
    "For sites in French Guiana, where there is information on the",
    "vernacular name but not on the scientific name, we add the scientific
    name",
    "that was most frequently associated to that vernacular name in the rest",
    "of the dataset."
  )
} else {
  text <- "If your site has only vernacular names, and if you have any
  information for the corresponding scientific names, please contact us to
  include the table in our analysis."
}
```

`r text`

```{r na-sp}
#| message: false
#| warning: false
if (anyNA(data_cor$scientific_cleaned)) {
  nb_na_sp <- sum(is.na(data_cor$scientific_cleaned))
  perc_na_sp <- round(
    sum(is.na(data_cor$scientific_cleaned)) * 100 / dim(data_cor)[1], 2
  )
  nb_na_sp_tree <- data_cor %>%
    filter(is.na(scientific_cleaned)) %>%
    summarise((length(unique(paste(Site, Plot, Subplot, IdTree)))))
  text <- paste(
    "In this dataset, there are",
    nb_na_sp,
    "observations with NAs in the scientific names, which represent",
    perc_na_sp,
    "% of the observations. This concerns",
    nb_na_sp_tree,
    "trees."
  )
} else {
  text <- "There are no unidentified trees."
}
```

`r text`

Here we have a figure showing the resolution of taxonomic identification in the data provided.

If you notice an inconsistency in this information, please let us know.

```{r display-taxo-resolution}
#| message: false
#| warning: false
#| fig.width: 10
#| fig.height: 8

if (params$print) {
  # Create plot
  # for (i in unique(data_cor$Site)) {
  data_cor |>
    # filter(Site == i) |>
    group_by(Site, Plot, Year) |>
    summarise(
      Undetermined = sum(is.na(genus_cleaned)) / length(genus_cleaned),
      `Genus Only` = sum(!is.na(genus_cleaned) & is.na(species_cleaned))
      / length(genus_cleaned),
      Species = sum(!is.na(species_cleaned)) / length(species_cleaned)
    ) |>
    pivot_longer(cols = c("Undetermined", "Genus Only", "Species")) |>
    mutate(
      name = factor(name, levels = c("Undetermined", "Genus Only", "Species"))
    ) |>
    ggplot(aes(as.character(Year), value, fill = name)) +
    geom_col() +
    facet_wrap(~Plot,
      scales = "free_y",
      labeller = label_both
    ) +
    scale_y_continuous(breaks = c(0, 0.5, 1)) +
    labs(
      fill = "ID level",
      title = "Proportion of taxonomic ID resolution"
    ) +
    labs(x = NULL, y = NULL) +
    theme_minimal() +
    theme(legend.position = "bottom") +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)
    ) +
    scale_fill_manual(values = c("#D53E4F", "#FEE08B", "#3288BD"))
  # }
}
```

# Check data consistency

This step checks for any anomalies in the data, that needs to be removed from the dataset, or modified.

## Consistency of diameter measurements

In this step, we will ensure the consistency of diameter measurements.

### Missing (NA) and zeros in DBH values

If this dataset contains any NAs or zeros, we will remove them in this step.

```{r check-na-dbh}
#| message: false
#| warning: false
if (anyNA(data_cor$Diameter)) {
  nb_na_dbh <- sum(is.na(data_cor$Diameter))
  perc_na_dbh <- round(
    sum(is.na(data_cor$Diameter)) * 100 / dim(data_cor)[1],
    2
  )
  text <- paste0(
    "In this dataset, there are ",
    nb_na_dbh,
    " missing diameters in the data, which represent ",
    perc_na_dbh,
    "% of the observations."
  )
} else {
  text <- "In this dataset, there are no missing diameters in the data."
}
```

`r text`

```{r check-zero-dbh}
#| message: false
#| warning: false
if (sum(data_cor$Diameter == 0, na.rm = TRUE) > 0) {
  nb_zero_dbh <- sum(data_cor$Diameter == 0, na.rm = TRUE)
  perc_zero_dbh <- round(
    sum(data_cor$Diameter == 0, na.rm = TRUE) * 100 / dim(data_cor)[1],
    2
  )
  text <- paste0(
    "In this dataset, there are ",
    nb_zero_dbh,
    " diameters with the value zero in the data, which represent ",
    perc_zero_dbh,
    "% of the observations."
  )
} else {
  text <- "In this dataset, there are no zeros in the diameters in the data."
}
```

`r text`

```{r na-zero-dbh}
#| message: false
#| warning: false

missing_values <- data_cor %>%
  filter(is.na(Diameter) | Diameter == 0) %>%
  group_by(Site, Plot, Year) %>%
  summarise(
    NAs = sum(is.na(Diameter)),
    Zeros = sum(!is.na(Diameter) & Diameter == 0)
  )

if (sum(missing_values$NAs) == 0) missing_values$NAs <- NULL
if (sum(missing_values$Zeros) == 0) missing_values$Zeros <- NULL

text <- ""
if (any(colnames(missing_values) %in% c("Zeros", "NAs"))) {
  text <- "Values are distributed in the dataset as follows:"
}
```

`r text`

```{r print-na-zero-dbh}
missing_values %>%
  knitr::kable()
```

```{r remove-na-zero-dbh}
#| message: false
#| warning: false

data_cor <- data_cor |>
  subset(Diameter > 0 & !is.na(Diameter))
```

As we have removed all the NAs and zeros, the DBH values in this dataset are NA and zero free.

### Check DBH cutoff

In this project, we are using various datasets from across the world which have different DBH limits. We want to ensure that there is one DBH cutoff throughout the data.

```{r get-dbh-cutoff}
#| message: false
#| warning: false
if (length(unique(data_cor$MinDBH)) == 1) {
  text <- paste(
    "There is a single DBH cutoff set to",
    unique(data_cor$MinDBH),
    "cm for this entire data set."
  )
} else {
  # count the number of cutoff > 10 cm per plot and census
  cutoff_plot_cens <- data_cor %>%
    group_by(Site, Plot) %>%
    summarise(n_cutoff_sup_10 = length(unique(MinDBH[MinDBH > 10])))
  if (all(cutoff_plot_cens$n_cutoff_sup_10 == 0)) {
    text <- paste(
      "In this dataset, all DBH cutoffs are at 10 cm or below;",
      "we will only use stems > 10 cm DBH."
    )
  } else {
    data_above_10 <- cutoff_plot_cens |>
      subset(n_cutoff_sup_10 > 0) |>
      mutate(idplot = paste(Site, Plot, sep = "-"))
    text <- paste(
      "In this dataset, the following plots have one or more DBH cutoffs",
      "above 10 cm DBH:",
      paste(data_above_10$idplot, collapse = ", ")
    )
  }
}
```

`r text`

```{r print-dbh-cutoff}
#| message: false
#| warning: false
if (length(unique(data_cor$MinDBH)) != 1 && isTRUE(params$print)) {
  data_cor %>%
    group_by(Site, Plot, IdCensus) %>%
    summarise(dbhcut = unique(MinDBH)) %>%
    knitr::kable()
}
```

As mentioned above, to maintain consistency, we will remove all stems below 10 cm, if there are any.

```{r remove-dbh-below-cutoff}
#| message: false
#| warning: false
if (with(data_cor, !any(Diameter < MinDBH | Diameter < 10))) {
  text <- "There are no stems with a DBH below the DBH cutoff or below 10 cm."
} else {
  n_below_cut <- with(data_cor, sum(Diameter < MinDBH & !is.na(Diameter)))
  n_below_10 <- with(data_cor, sum(Diameter < 10 & !is.na(Diameter)))

  text <- paste("There are ",
    n_below_cut,
    " observations of stems with a DBH below their DBH cutoff (",
    round(n_below_cut * 100 / dim(data_cor)[1], 2),
    "%), with a difference ranging ",
    subset(data_cor, Diameter < MinDBH) |>
      with(MinDBH - Diameter) |>
      range() |>
      round(3) |>
      paste(collapse = "-"),
    " cm between the observation and the cutoff, and a median difference of ",
    subset(data_cor, Diameter < MinDBH) |>
      with(MinDBH - Diameter) |>
      median() |>
      round(2),
    " cm. There were ",
    n_below_10,
    " observations with a DBH below 10 cm (",
    round(n_below_10 * 100 / dim(data_cor)[1], 1),
    "%). These observations are removed, leaving a dataset of ",
    dim(data_cor)[1],
    " observations.",
    sep = ""
  )
}

data_cor <- data_cor %>% filter(Diameter >= MinDBH & Diameter >= 10)
```

`r text`

## Avoid duplicated measurements

We want to make sure that there are no duplicated measurements in the data. So we create a unique identifier for each stem by combining the name of the site, plot, subplot and tag/ID of the tree and stem. We then check that there are no duplicated measurements for the same stem ID in a given census.

If we find duplicates, only the first observation is retained in the data.

```{r get-stem-id-iwokrama}
if (any(data_cor$Site == "Iwokrama")) {
  data_cor <- data_cor |>
    mutate(IdTree = NULL) |>
    separate_wider_delim(IdStem, "_", names = c("IdTree", NA, NA, "IdStem", NA))
  text <- paste(
    "In Iwokrama, we have removed census year information from the",
    "stem ID so that measurements of the same stem can be matched",
    "across censuses."
  )
} else {
  text <- ""
}
```

`r text`

```{r complete-idstem}
#| message: false
#| warning: false
data_cor <- data_cor |>
  mutate(IdTree = paste(Site, Plot, Subplot, IdTree, sep = "_")) |>
  mutate(IdStem = paste(IdTree, IdStem, sep = "_"))
```

```{r print-duplicated-stems}
#| message: false
#| warning: false
nb_stem_plot <- data_cor %>%
  count(IdStem, IdCensus)

if (all(length(unique(nb_stem_plot$n)) == 1, unique(nb_stem_plot$n) == 1)) {
  text <- ""
} else {
  stem_dupli <- nb_stem_plot %>%
    filter(n > 1)
  text <- paste("In this dataset, there are ",
    dim(stem_dupli)[1],
    " cases of duplicated stem identifiers within a same census,",
    " with duplications. These duplications concern ",
    length(unique(stem_dupli$IdStem)),
    " stems.",
    sep = ""
  )
}
```

`r text`

```{r rmv-full-duplicated-stems}
#| message: false
#| warning: false
if (length(unique(nb_stem_plot$n)) != 1) { # if there are some duplicates
  prev_nb_obs <- dim(data_cor)[1]
  data_cor <- data_cor %>% distinct() # remove fully duplicated rows
  # if there were some fully duplicated rows:
  if (prev_nb_obs - dim(data_cor)[1] != 0) {
    text <- paste(
      prev_nb_obs - dim(data_cor)[1],
      "rows are true duplicates (fully identical rows).",
      "These true duplicates are removed from the dataset,",
      "leaving a dataset of", dim(data_cor)[1], "observations."
    )
  } else {
    text <- ""
  }
  nb_stem_plot_bis <- data_cor %>%
    count(IdStem, IdCensus)
} else { # if no duplicated rows
  text <- paste(
    "We checked for true duplicates (fully identical rows), and",
    "there are none in this dataset."
  )
}
```

`r text`

```{r remaining-duplicated-stems}
#| message: false
#| warning: false
text <- ""
if (length(unique(nb_stem_plot$n)) != 1) { # if there are some duplicates
  if (all(
    length(unique(nb_stem_plot_bis$n)) == 1,
    unique(nb_stem_plot_bis$n) == 1
  )) {
    still_stem_dupli <- FALSE
  } else {
    stem_dupli_bis <- nb_stem_plot_bis %>%
      filter(n > 1)
    text <- paste(
      "In this dataset, there are still",
      dim(stem_dupli_bis)[1],
      "cases of duplicated stem identifiers within the same census,",
      "which are not fully replicated rows."
    )
    if (dim(stem_dupli_bis)[1] < 20) {
      text <- paste("This concern the following cases:")
      still_stem_dupli <- TRUE
    } else {
      still_stem_dupli <- TRUE
    }
  }
} else {
  still_stem_dupli <- FALSE
}
```

`r text`

```{r print-remaining-duplicated-stems}
#| message: false
#| warning: false
text <- ""
if (still_stem_dupli == TRUE) {
  if (dim(stem_dupli_bis)[1] > 20) {
    text <- paste(
      # "There are still ", nrow(stem_dupli_bis), " stem duplicates. ",
      "As the number is too high, we are unable to print all the stem names, and
      will print only the first 10 rows.",
      "Please check your data or discuss with us on why this might be happening.
      "
    )
    stem_dupli_bis[1:10, ] %>%
      select(IdStem, IdCensus) %>%
      knitr::kable()
  } else {
    stem_dupli_bis %>%
      select(IdStem, IdCensus) %>%
      knitr::kable()
  }
}
```

`r text`

```{r warn-remaining-duplicated-stems}
#| message: false
#| warning: false
text <- ""
if (still_stem_dupli == TRUE) {
  text <- paste(
    "IMPORTANT: Please check these cases in your raw data before starting the",
    "process again. For now, we have only kept the first measurement of these",
    "duplicate stems, but please let us know how we can better deal with these",
    "duplicate measurements."
  )
  data_cor <- data_cor |>
    subset(!duplicated(paste(IdStem, IdCensus)))
} else {
  text <- "There are no more duplicates measurements in this dataset.
  We will now move on to checking for multi-stemmed trees."
}
```

`r text`

## Check multi-stemmed trees

The next step is to make sure the dataset as a realistic number of multi-stem trees.

```{r check-multi-stems}
#| message: false
#| warning: false
data_nstem <- data_cor |>
  group_by(Site, Plot, Subplot, IdTree) |>
  summarise(nstem = length(unique(IdStem)))
if (all(data_nstem$nstem == 1)) {
  text <- paste(
    "In this dataset, the number of stem identifiers and the number of tree",
    "identifiers are equal, suggesting either that there are no multi-stemmed",
    "trees, or that the multiple stems are considered as different individuals."
  )
} else {
  text <- "In this dataset, the following trees have multiple stems:"
}
```

`r text`

```{r}
#| message: false
#| warning: false
text <- ""
if (any(data_nstem$nstem != 1)) {
  multi_stemmed <- subset(data_nstem, nstem > 1)
  if (nrow(multi_stemmed) <= 10) {
    multi_stemmed |>
      knitr::kable()
  } else {
    text <- paste(
      "There are", nrow(multi_stemmed), "multi-stemmed trees.",
      "As the number is too high, we are unable to print all the stem names,
      and we are printing only the first 10 rows.",
      "Please check your data or discuss with us if this is to be expected."
    )
    multi_stemmed[(1:10), ] |>
      knitr::kable()
  }
}
```

`r text`

## Keep only live trees

We want to ensure that this dataset contains only live trees, so we carry out 2 steps:

### Remove dead trees

```{r remove-dead}
#| message: false
#| warning: false
alive <- c(1:4, TRUE, NA, "Normal", "Recruit")
text <- ""
# embrapa sites : CIF <= 5: live trees
if ("LifeStatus" %in% colnames(data_cor) & params$site != "uppangala") { # nolint
  n_dead <- sum(!data_cor$LifeStatus %in% alive)
  if (n_dead > 0) {
    text <- paste0(
      n_dead, " (", round(n_dead / nrow(data_cor) * 100, 2), "%) measurements",
      " with Diameter > min DBH were considered as dead, and removed from the ",
      "analysis. Their LifeStatus values of trees considered dead were: ",
      paste(unique(
        setdiff(data_cor$LifeStatus, alive)
      ), collapse = ", "),
      "."
    )
  } else {
    text <- paste(
      "No measurements (with Diameter > min DBH) were",
      "identified as dead trees in the data."
    )
  }

  data_cor <- data_cor |> subset(LifeStatus %in% alive)
} else {
  text <- paste(
    "In this dataset, all stem measurements are assumed to be from living",
    "trees. Please let us know if any dead measurements should be removed and",
    "how to identify them in the data."
  )
}
```

The first step is to remove all the dead individuals if there is a column called "LifeStatus". We keep the rows with the character strings: `r paste(alive, collapse = ", ")`. If your dataset has any other code to represent live/dead trees, please let us know.

`r text`

```{r}
#| message: false
#| warning: false

text <- ""
if (any(data_cor$Site == "STREK")) {
  # in strek, dead trees are marked with the code 999 in their DBH
  data_cor <- data_cor |>
    filter(!grepl("999", Diameter) & !grepl("999", Circ))
  text <- paste(
    "In STREK, we removed all trees with diameter or circumference",
    "values containing 999 as they are considered dead."
  )
}
```

`r text`

### Remove life forms other than trees

The second step is to remove any other life forms apart from trees, such as Lianas, palms, cacti etc. We use the column "LifeForm" when present, and remove the rows with names: "palm","palms", "tree fan", "death", "vine", "vines", "lianas". If your dataset has other life forms to remove, please let us know.

```{r select-life-form}
#| message: false
#| warning: false
text <- ""
if ("LifeForm" %in% colnames(data_cor)) {
  data_cor <- data_cor |>
    mutate(lifeform = tolower(gsub("s$", "", LifeForm))) |>
    mutate(lifeform = ifelse(
      (!is.na(family_cleaned) & family_cleaned == "Arecaceae") |
        # Astrocaryum vernacular name in Paracou, only identified to vern name
        (!is.na(VernName) & VernName == "murumuru"), "palm", lifeform
    )) |>
    mutate(lifeform = ifelse(
      !is.na(family_cleaned) &
        family_cleaned %in% c(
          "Cyatheaceae", "Dicksoniaceae",
          "Metaxyaceae", "Cibotiaceae"
        ),
      "tree fern", lifeform
    ))

  other_lf <- data_cor |>
    subset(lifeform %in% c(
      "palm", "tree fan", "tree fern",
      "death", "vine", "liana"
    )) |>
    group_by(lifeform) |>
    summarise(n = n())
  if (nrow(other_lf) > 0) {
    text <- paste(
      "We removed",
      with(other_lf, paste(n, lifeform)) |> paste(collapse = ", "),
      "measurements, i.e.",
      round(sum(other_lf$n) / nrow(data_cor) * 100, 2),
      "% of all measurements."
    )
    data_cor <- data_cor |>
      subset(!lifeform %in% c("palm", "tree fan", "death", "vine", "liana"))
  } else {
    text <- paste(
      "Based on the 'LifeForm' column, we did not find any life",
      "forms other than trees. Please let us know if this is not the case."
    )
  }
} else {
  text <- paste(
    "In this dataset, there was no column 'LifeForm' with information about",
    "life forms (such as trees, lianas, palms), so we assume that all",
    "individuals in your dataset are trees. Please let us know if that is not",
    "the case."
  )
}
```

`r text`

### Ensure one scientific name per tree

We want to now ensure that individuals have the same scientific name across censuses.

```{r one-sp-per-tree}
#| message: false
#| warning: false
text <- ""
duplicated_species <- data_cor %>%
  group_by(IdTree) %>%
  summarise(
    nbsp = n_distinct(scientific_cleaned, na.rm = TRUE),
    nbsp_na = n_distinct(scientific_cleaned, na.rm = FALSE)
  )

data_cor <- data_cor %>%
  group_by(IdTree) %>%
  arrange(Year) %>%
  mutate(scientific_cleaned = last(scientific_cleaned, na_rm = TRUE)) %>%
  ungroup()

if (all(duplicated_species$nbsp_na < 2)) { # no duplicated names
  text <- paste(
    "There was always only one scientific name for a given individual (or",
    "always a NA). No change has been made."
  )
} else {
  # if some correction have been made
  text <- paste(
    "There were",
    with(duplicated_species, sum(nbsp_na == 2 & nbsp == 1)),
    "observations with NA in the scientific names, but with a unique",
    "(non-NA) scientific name.",
    "There were",
    sum(duplicated_species$nbsp > 1),
    "observations with more than one non-NA scientific name.",
    "In all these cases, we used the last non-NA scientific name recorded",
    "for each tree."
  )
}
```

`r text`

# DBH corrections

The following flowchart summarises the corrections applied to DBH and DBH changes. The steps (yellow rectangles) are explained and illustrated in each subsection.

![Flowchart of DBH corrections](flowchart.png)

```{r create-diameter_cor}
#| message: false
#| warning: false
data_cor$diameter_cor <- data_cor$Diameter
```

## Detect misplaced decimals 

Some trees have abnormally larger diameters because the decimal was misplaced. We check all diameter measurements $\geq$ 100 cm: if the value divided by 10 is within 10% of the range of other diameter values of the same stem, we keep the new measurement (divided by 10). 

```{r correct-decimals}
detect_decimal <- function(x, lim = 100) {
  if (length(x) > 1 & sum(x > lim) == 1) { # nolint
    if (any((x[x > lim] / 10 > 0.9 * min(x[x <= lim])) &
      (x[x > lim] / 10 < 1.1 * max(x[x <= lim])))) { # nolint
      return(x > lim)
    } else {
      return(rep(FALSE, length(x)))
    }
  } else {
    return(rep(FALSE, length(x)))
  }
}
data_cor <- data_cor |>
  group_by(IdStem) |>
  mutate(
    diameter_cor =
      diameter_cor / ifelse(detect_decimal(diameter_cor), 10, 1)
  ) |>
  ungroup()

if (sum(data_cor$Diameter != data_cor$diameter_cor) > 0) {
  text <- paste(
    "We have changed",
    sum(data_cor$Diameter != data_cor$diameter_cor),
    "measurements."
  )
} else {
  text <- ""
}
```

```{r}
if (with(data_cor, sum(Diameter != diameter_cor) > 0)) {
  id_cor <- subset(data_cor, Diameter != diameter_cor)$IdStem |> unique()
  if (length(id_cor) > 12) id_cor <- sample(id_cor, 12)
  data_cor |>
    filter(IdStem %in% id_cor) |>
    ggplot(aes(Year)) +
    labs(y = "Diameter (cm)", col = "Was the DBH\ndivided by 10?") +
    geom_point(aes(y = diameter_cor), col = "forestgreen") +
    geom_point(aes(y = Diameter, col = diameter_cor != Diameter)) +
    scale_color_manual(values = c("black", "red")) +
    facet_wrap(~IdStem, scales = "free") +
    theme_minimal()
}
```

## Taper correction

Trees measured above the standard height of 1.3 m (e.g. if they have irregular trunks at 1.3 m due to buttresses) will have a smaller diameter measured than their actual DBH due to trunk taper. To correct for this systematic bias, taper corrections have been developed to estimate DBH based on the measured diameter and the height at which it was measured.

```{r taper-correction}
#| message: false
#| warning: false
taper_function <- function(diam, hom) {
  # default hom (no correction) when there is no reliable information
  hom[is.na(hom) | hom <= 0 | hom > 20] <- 1.3
  b <- exp(-2.0205 - 0.5053 * log(diam) + 0.3748 * log(hom))
  return(diam * exp(b * (hom - 1.3)))
}

if (params$taper) {
  if (any(colnames(data_cor) == "HOM")) {
    if (any(data_cor$HOM != 1.3)) {
      text <- paste(
        "The taper correction estimates DBH for diameter values measured above",
        "breast height. We used the function from function from Cushman et al.",
        "(2014): DBH = D.exp(b(HOM - 1.3)) where DBH is the estimated diameter",
        "at breast height, D is the measured diameter (cm) at height of",
        "measurement HOM (m) and b is defined as follows:\n",
        "b = exp(-2.0205 - 0.5053 ln(diam) + 0.3748 ln(HOM))."
      )
      # harmonize HOM values
      data_cor <- data_cor |>
        mutate(HOM = as.numeric(HOM)) |>
        # some values in cm: convert to m
        mutate(HOM = ifelse(HOM >= 50, HOM / 100, HOM)) |>
        # apply correction
        mutate(diameter_cor = taper_function(diameter_cor, HOM))

      subset(data_cor, HOM != 1.3) |>
        ggplot(aes(x = Diameter, y = diameter_cor, col = HOM)) +
        geom_abline(intercept = 0, slope = 1, lty = 2) +
        geom_point() +
        labs(
          x = "Original diameter (cm)",
          y = "Taper-corrected diameter (cm)"
        ) +
        scale_color_viridis_c() +
        theme_classic()
    } else {
      text <- paste(
        "All measurements were recorded as having been taken at HOM = 1.3 m,",
        "so we did not need to apply a taper correction."
      )
    }
  } else {
    text <- paste(
      "There is no information on height of measurement,",
      "so we could not apply any taper correction."
    )
  }
} else {
  text <- paste(
    "After testing various taper correction equations (Cushman et al. 2014,
    2021), we found that these equations over-corrected the data at most sites
    and introduced a new bias. Until we find a taper correction that's better
    suited to Bioforest sites, we decided not to correct for taper."
  )
}
```

`r text`

## Interpolation of missing measurements

If trees are missed in a census and remeasured in a later census, we use the DBH values from the previous and next census to interpolate the missing DBH value(s).

This can lead to bias in the first and last censuses where missing DBH cannot be detected. We need to check that recruitment and mortality rates are not systematically lower in these two censuses.

```{r interpolate-missing-dbh}
#| message: false
#| warning: false
interpolate <- function(diam, years) {
  if (sum(!is.na(diam)) > 1) {
    return(approx(years, diam, years)$y)
  } else {
    return(diam)
  }
}

# columns with tree-level information in data_cor
col_tree <-
  !grepl(
    "census|year|month|day|date|status|code|diam|hom|pom|circ|dbh",
    tolower(colnames(data_cor))
  )
col_pattern <- "Census|Year|Month|Day|Date|Status|Code|Diam|HOM|POM|Circ|DBH"

tree_info <- data_cor |>
  select(c("Year", colnames(data_cor)[col_tree])) |>
  group_by(Site, Plot, IdStem) |>
  filter(Year == max(Year)) |>
  select(-Year)

missing_censuses <- data_cor |>
  # list all census years by plot and subplot
  group_by(Site, Plot, Subplot) |>
  reframe(year_census = unique(year_census)) |>
  ungroup() |>
  # add all combinations of IdStem x IdCensus (by Plot and Subplot)
  right_join(
    unique(data_cor[, c("Site", "Plot", "Subplot", "IdStem")]),
    by = c("Site", "Plot", "Subplot")
  ) |>
  # add tree-level information
  merge(tree_info) |>
  # add DBH information
  merge(
    data_cor[, c("IdStem", "year_census", "diameter_cor")],
    by = c("IdStem", "year_census"),
    all = TRUE
  ) |>
  # interpolate missing diameters
  group_by(IdStem) |>
  mutate(
    diameter_cor = interpolate(diameter_cor, year_census)
  ) |>
  subset(!is.na(diameter_cor)) |>
  # keep only measurements missing from original data:
  subset(!paste(IdStem, year_census) %in%
    with(data_cor, paste(IdStem, year_census))) |> # nolint
  mutate(Year = year_census)

# add interpolated DBHs to raw data
data_cor <- bind_rows(
  data_cor,
  missing_censuses
)
rm(missing_censuses)

if (sum(is.na(data_cor$Diameter)) > 0) {
  n_missing <- sum(is.na(data_cor$Diameter))
  stem_missing <- length(unique(data_cor$IdStem[is.na(data_cor$Diameter)]))
  text <- paste(
    "We found a total of", sum(is.na(data_cor$Diameter)),
    "missing DBH values, in", stem_missing, "stems.",
    "The figure below shows a subset of", min(stem_missing, 12),
    "trees with missing DBH (red points are interpolated DBH)."
  )
} else {
  text <- "No missing DBH values were interpolated."
}
```

`r text`

```{r fig-interpolate, fig.height=7, fig.width=11}
#| message: false
#| warning: false
if (sum(is.na(data_cor$Diameter)) > 0 && isTRUE(params$print)) {
  illustration <- sample(
    subset(data_cor, is.na(Diameter))$IdStem,
    min(stem_missing, 12)
  )
  subset(data_cor, IdStem %in% illustration) |>
    separate(IdTree, c(NA, NA, NA, "IdTree"), sep = "_") |>
    mutate(label = paste0(
      "Plot: ", Plot, "_", Subplot,
      ", treeID: ", IdTree, "\n Species: ", scientific_cleaned
    )) |>
    ggplot(aes(x = Year, y = diameter_cor)) +
    geom_point(aes(col = is.na(Diameter))) +
    labs(x = "Census year", y = "Diameter (cm)", col = "Interpolated") +
    scale_color_manual(values = c("black", "red")) +
    facet_wrap(~label, scales = "free") +
    theme_classic() +
    theme(legend.position = "bottom")
}
```

## Substitute excessive DBH changes

Growth and productivity measurements are very sensitive to large changes in DBH, for example when the measurement height is changed. To mitigate this problem, we replace excessive DBH changes with the average growth value of similar trees (without changing the DBH values).

This poses two challenges: 1. what can be considered an 'excessive' DBH change and 2. how to define 'similar' trees.

```{r estimate-dbh-growth}
#| message: false
#| warning: false
data_years <- data_cor |>
  select(Site, Plot, Subplot, Year) |>
  unique() |>
  group_by(Site, Plot, Subplot) |>
  arrange(Year, .by_group = TRUE) |>
  mutate(prev_year = c(NA, Year[-length(Year)]))
data_cor <- data_cor |>
  merge(data_years, by = c("Site", "Plot", "Subplot", "Year"), all.x = TRUE) |>
  group_by(IdStem) |>
  arrange(Year, .by_group = TRUE) |>
  mutate(
    diam_growth = c(NA, diff(diameter_cor)) / (Year - prev_year),
    diff_year = (Year - prev_year)
  ) |>
  ungroup()
```

Here we defined 'similar' trees by first grouping them by genus and size (DBH), assuming that these two factors are among the main drivers of tree growth. We ranked genera by median DBH growth and divided them into four groups of increasing median DBH growth, with similar numbers of individual measurements per group.

```{r gen-groups}
#| message: false
#| warning: false
genus_groups <- data_cor %>%
  filter(!is.na(genus_cleaned)) %>%
  # get median growth (excluding negative values) per genus
  group_by(genus_cleaned) %>%
  mutate(med_growth = median(diam_growth[diam_growth >= 0], na.rm = TRUE)) %>%
  ungroup() %>%
  # create quantile bins with equal number of individuals
  mutate(gen_group = ntile(med_growth, 4)) %>%
  group_by(genus_cleaned, med_growth) %>%
  # summarize back to species level
  summarise(gen_group = first(gen_group), .groups = "drop")
```

```{r gen-group-visualisation}
#| message: false
#| warning: false
if (any(!is.na(genus_groups$med_growth))) {
  genus_groups |>
    subset(!is.na(gen_group) & !is.na(genus_cleaned)) |>
    group_by(gen_group) |>
    summarise(
      range = paste(
        paste(round(range(med_growth), 2), collapse = " - "),
        "cm/yr"
      ),
      genus = paste(genus_cleaned, collapse = ", ")
    ) |>
    select(range, genus) |>
    t() |>
    knitr::kable(
      col.names = paste(
        "Group", seq_len(length(unique(drop_na(genus_groups)$gen_group)))
      ),
      row.names = FALSE
    )
}
```

We then split each genus group into 5 quantiles of DBH: this results in 20 groups of DBH growth measures based on both genus-level growth rates and size (DBH).

Outliers are defined here as the 0.5% lowest DBH growth values (all groups combined) and the 0.5% highest DBH growth values per group. These outliers in DBH growth were replaced by the mean growth of their group.

```{r substitute-dbh-change}
#| message: false
#| warning: false
data_cor <- data_cor |>
  left_join(genus_groups, by = "genus_cleaned") |>
  group_by(gen_group) |>
  mutate(diam_group = paste(gen_group, ntile(diameter_cor, 5), sep = "_")) |>
  # lower diameter growth threshold is the same for all species and sizes
  ungroup() |>
  mutate(
    dgrowth_lower = quantile(diam_growth, 0.005, na.rm = TRUE),
    # define general upper quantile for unidentified individuals
    dgrowth_upper = quantile(diam_growth, 0.995, na.rm = TRUE)
  ) |>
  # upper diameter growth threshold defined by species and size
  group_by(diam_group) |>
  mutate(dgrowth_upper = ifelse(!is.na(gen_group),
    quantile(diam_growth, 0.995, na.rm = TRUE),
    dgrowth_upper
  )) |>
  # define outlier values
  mutate(outlier = !is.na(diam_growth) &
    (diam_growth < dgrowth_lower | diam_growth > dgrowth_upper)) |> # nolint
  # estimate average growth by group
  mutate(average_growth = mean(diam_growth[!outlier], na.rm = TRUE)) |>
  ungroup() |>
  # substitute diameter growth
  mutate(diam_growth_cor = ifelse(outlier, average_growth, diam_growth))
```

```{r}
#| message: false
#| warning: false
if (sum(data_cor$outlier) > 0) {
  text <- paste(
    "This graph shows all outlier DBH growth values (in cm/yr),",
    "as well as the lower and upper bounds of 'acceptable' DBH",
    "growth (in red) and the average DBH growth with which outlier",
    "values are replaced (blue), as a function of tree DBH and",
    "genus groups."
  )
} else {
  text <- paste(
    "There were no diameter growth values to correct, as no stem",
    "was measured more than once."
  )
}
```

`r text`

```{r dbh-change-fig}
#| warning: false
#| message: false
#| fig.height: 7
#| fig.width: 11

if (sum(data_cor$outlier) > 0 && isTRUE(params$print)) {
  data_thresh <- data_cor |>
    subset(!is.na(gen_group)) |>
    group_by(gen_group, diam_group) |>
    summarise(
      diam_min = min(diameter_cor),
      diam_max = max(diameter_cor),
      dgrowth_upper = unique(dgrowth_upper),
      dgrowth_lower = unique(dgrowth_lower),
      average_growth = unique(average_growth)
    ) |>
    pivot_longer(cols = c("diam_max", "diam_min"))
  data_cor |>
    subset(outlier) |>
    ggplot(aes(x = diameter_cor, y = diam_growth)) +
    geom_point() +
    geom_line(data = data_thresh, aes(x = value, y = dgrowth_upper), col = 2) +
    geom_line(data = data_thresh, aes(x = value, y = dgrowth_lower), col = 2) +
    geom_line(data = data_thresh, aes(x = value, y = average_growth), col = 4) +
    labs(x = "Diameter (cm)", y = "Diameter growth (cm/yr)") +
    ylim(-5, 10) +
    facet_wrap(~ paste("Genus group", gen_group)) +
    scale_x_log10() +
    theme_classic()
}
```

```{r}
#| message: false
#| warning: false
if (sum(data_cor$outlier) > 0) {
  text <- paste(
    "The graph below shows a subset of trees with outlier DBH",
    "growth values; the top panels show the DBH growth values and",
    "the bottom panels show the corresponding DBH values (one",
    "column per tree). The red dots are the outlier DBH growth",
    "values, which were then replaced by the average growth values",
    "for their group (species x DBH). DBH values were not replaced."
  )
} else {
  text <- ""
}
```

`r text`

```{r show-examples-substitution}
#| warning: false
#| fig.height: 6
#| fig.width: 12

if (sum(data_cor$outlier) > 0 && isTRUE(params$print)) {
  id_cor <-
    data_cor |>
    subset(outlier) |>
    group_by(gen_group) |>
    summarise(id = sample(unique(IdStem), min(2, length(unique(IdStem)))))

  labs_diam <- c(
    diam_growth = "Diameter growth rate (cm/yr)",
    diameter_cor = "Diameter (cm)"
  )
  data_cor |>
    subset(IdStem %in% id_cor$id) |>
    separate(IdTree, c(NA, NA, NA, "IdTree"), sep = "_") |>
    mutate(label = paste0(
      "Plot: ", Plot, "_", Subplot,
      "\ntreeID: ", IdTree, "\n", scientific_cleaned
    )) |>
    pivot_longer(cols = c("diam_growth", "diameter_cor")) |>
    ggplot(aes(x = Year)) +
    geom_point(aes(y = value, col = outlier)) +
    labs(col = "Outlier DBH growth?", y = NULL) +
    scale_color_manual(values = c("black", "red")) +
    facet_grid(name ~ label,
      scales = "free", switch = "y",
      labeller = labeller(name = labs_diam)
    ) +
    theme_bw() +
    theme(
      legend.position = "bottom", strip.placement = "outside",
      strip.background.y = element_blank()
    )
}
```

# Data aggregation

The last step of this document is to calculate and visualize all the variables of interest. We divided the variables into 3 sections: 1. Neutral diversity 2. Functional diversity and composition 3. Structural diversity

```{r create-data_aggr}
#| message: false
#| warning: false
rm(list = setdiff(ls(), c("data_cor", "params")))
data_aggr <- c()
```

```{r diff-year}
#| message: false
#| warning: false
# for each census year, add information on previous and next census years
data_year <- data_cor |>
  ungroup() |>
  select(Site, Plot, year_census) |>
  unique() |>
  drop_na() |>
  arrange(Site, Plot, year_census) |>
  group_by(Site, Plot) |>
  mutate(
    prev_census = c(NA, year_census[-length(year_census)]),
    next_census = c(year_census[-1], NA)
  ) |>
  ungroup()

# add information on each tree's recruitment and mortality years
data_cor <- data_cor |>
  left_join(data_year) |>
  mutate(
    recr_year = min(year_census),
    mort_year = max(year_census), .by = IdStem
  )
```

## Taxonomic Diversity

To evaluate taxonomic diversity, we used functions from the entropart package in R (Marcon et al., 2020). We estimated all these indices at both species and genus level.

We quantified taxonomic diversity using Hill numbers, a family of diversity measures that account for both species richness and evenness.

### Species Richness

Diversity of Order q = 0: Species richness, which counts all species equally, regardless of their abundance.

### Shannon Diversity

Diversity of Order q = 1: Shannon diversity, calculated as the exponential of Shannon entropy, which gives proportional weight to species based on their relative abundances. This index balances sensitivity to both common and rare species.

### Simpson Diversity

Diversity of Order q = 2: Simpson diversity, calculated as the inverse of the Simpson index, which emphasizes dominant species and is less sensitive to rare taxa.

### Evenness

Evenness reflects how uniformly individuals are distributed among the observed species. It was derived by dividing the observed diversity (for a given value of q) by the theoretical maximum diversity for the same number of species. Values closer to 1 indicate communities where individuals are more evenly distributed across species, while lower values indicate dominance by a few species.

### Coverage

Sample coverage estimates the proportion of individuals in a community that belong to species already detected in the sample. It provides an indication of sampling completeness, with values approaching 1 suggesting that most of the community has been captured and that further sampling is unlikely to yield many additional species.

The following figures represent all the above mentioned indices at the species and genus level. The y axis shows the different census years, while the x-axis shows the value of the indices. The different coloured lines represent the plots.

```{r neutral-diversity}
#| message: false
#| warning: false
# Calculate neutral diversity indices per plot and year

# species
neutral_div_sp <- data_cor %>%
  subset(!is.na(species_cleaned)) %>%
  group_by(Site, Plot, Year = year_census, scientific_cleaned) %>%
  summarise(count = n(), .groups = "drop") %>%
  group_by(Site, Plot, Year) %>%
  summarise(
    diversity_q0_sp = Diversity(count,
      q = 0, SampleCoverage = 0.8,
      Correction = "None"
    ),
    diversity_q1_sp = Diversity(count,
      q = 1, SampleCoverage = 0.8,
      Correction = "None"
    ),
    diversity_q2_sp = Diversity(count,
      q = 2, SampleCoverage = 0.8,
      Correction = "None"
    ),
    evenness_sp = Shannon(count, SampleCoverage = 0.8, Correction = "None") /
      log(n_distinct(scientific_cleaned)),
    coverage_sp = Coverage(count)
  ) %>%
  pivot_longer(
    cols = contains("_sp"),
    names_to = "variable",
    values_to = "value"
  )

# genera
neutral_div_gen <- data_cor %>%
  subset(!is.na(genus_cleaned)) %>%
  group_by(Site, Plot, Year = year_census, genus = genus_cleaned) %>%
  summarise(count = n(), .groups = "drop") %>%
  group_by(Site, Plot, Year) %>%
  summarise(
    diversity_q0_gen = Diversity(count,
      q = 0, SampleCoverage = 0.9,
      Correction = "None"
    ),
    diversity_q1_gen = Diversity(count,
      q = 1, SampleCoverage = 0.9,
      Correction = "None"
    ),
    diversity_q2_gen = Diversity(count,
      q = 2, SampleCoverage = 0.9,
      Correction = "None"
    ),
    evenness_gen = Shannon(count, SampleCoverage = 0.9, Correction = "None") /
      log(n_distinct(genus)),
    coverage_gen = Coverage(count)
  ) %>%
  pivot_longer(
    cols = contains("_gen"),
    names_to = "variable",
    values_to = "value"
  )

# Add to main dataframe with aggregatd data
data_aggr <- data_aggr %>%
  rbind(neutral_div_sp) %>%
  rbind(neutral_div_gen)
```

```{r function-fig}
#| message: false
#| warning: false
aggr_fig <- function(data, vars_names, title_fig = NULL) {
  g <- data %>%
    subset(variable %in% names(var_names)) %>%
    ggplot(aes(x = Year, y = value, color = paste(Site, Plot))) +
    geom_line(show.legend = FALSE) +
    geom_point(show.legend = (length(unique(data$Plot)) <= 28)) +
    facet_wrap(~variable,
      scales = "free_y",
      labeller = labeller(variable = var_names)
    ) +
    labs(
      title = title_fig,
      x = NULL, y = NULL, color = NULL
    ) +
    theme_minimal() +
    guides(col = guide_legend(ncol = 2))

  if (length(var_names) == 5) {
    g + theme(legend.position = c(0.82, 0.17))
  } else {
    g
  }
}
```


```{r neutral-diversity-fig}
#| message: false
#| warning: false
#| fig.height: 6
#| fig.width: 8

# Plot temporal trajectories of different indices across plots
if (isTRUE(params$print)) {
  var_names <- c(
    coverage = "Coverage",
    diversity_q0 = "Richness",
    diversity_q1 = "Shannon Diversity",
    diversity_q2 = "Simpson Diversity",
    evenness = "Evenness"
  )

  data_aggr %>%
    subset(variable %in% neutral_div_sp$variable) %>%
    mutate(variable = factor(gsub("_sp", "", variable),
      levels = c(
        paste0("diversity_q", 0:2),
        "evenness", "coverage"
      )
    )) %>%
    aggr_fig(var_names,
      title_fig = paste(
        "Diversity Indices Across Plots and Years",
        "(Species level)"
      )
    )

  data_aggr %>%
    subset(variable %in% neutral_div_gen$variable) %>%
    mutate(variable = factor(gsub("_gen", "", variable),
      levels = c(
        paste0("diversity_q", 0:2),
        "evenness", "coverage"
      )
    )) %>%
    aggr_fig(var_names,
      title_fig = paste(
        "Diversity Indices Across Plots and Years",
        "(Genus level)"
      )
    )
}
```



## Functional diversity and composition

To evaluate the functional structure of plant communities, we assessed both functional composition and functional diversity using a set of ecologically meaningful plant traits. 

### Functional composition

We quantified the functional composition as the community-weighted mean (CWM) for each trait, representing the average trait value in a community, weighted by species' relative abundances.

The traits computed in the analysis were:

#### Leaf area
Associated with light capture and leaf construction cost

#### Leaf nitrogen content per leaf dry mass
Reflects photosynthetic capacity and nutrient-use strategy.

#### Specific leaf area (SLA)
Indicates growth rate and resource acquisition.

#### Stem specific wood density
Related to mechanical strength, water transport efficiency, and survival strategies.


The following figures represent all the above mentioned indices. The y axis shows the different census years, while the x-axis shows the value of the indices. The different coloured lines represent the plots.

```{r functional-composition-ba}
#| message: false
#| warning: false

data_aggr <- data_cor |>
  group_by(Site, Plot, Year = year_census, scientific_cleaned) |>
  reframe(ba = (diameter_cor / 200)^2 * pi) |>
  inner_join(read.delim("data/derived_data/traits_v6.tsv"),
    by = "scientific_cleaned"
  ) |>
  filter(!is.na(genus_trait_value_imputed)) |>
  group_by(Site, Plot, Year, variable = paste0(trait, "_cwm_ba")) |>
  reframe(value = exp(weighted.mean(log(genus_trait_value_imputed), ba))) |>
  rbind(data_aggr)
```

```{r functional-composition-n}
#| message: false
#| warning: false
data_aggr <- data_cor |>
  group_by(Site, Plot, Year = year_census, scientific_cleaned) |>
  reframe(ba = (diameter_cor / 200)^2 * pi) |>
  inner_join(read.delim("data/derived_data/traits_v6.tsv"),
    by = "scientific_cleaned"
  ) |>
  filter(!is.na(genus_trait_value_imputed)) |>
  group_by(Site, Plot, Year, variable = paste0(trait, "_cwm_n")) |>
  reframe(value = exp(mean(log(genus_trait_value_imputed)))) |>
  rbind(data_aggr)
```

```{r fig-functional-composition}
#| message: false
#| warning: false
#| fig.height: 6
#| fig.width: 8

if (isTRUE(params$print)) {
  var_names <- c(
    "LA_cwm_n" = "Leaf area (mm2)",
    "N_cwm_n" = "Leaf nitrogen content \n per leaf dry mass \n (mg g-1)",
    "SLA_cwm_n" = "Specific leaf area \n (mm2 mg-1)",
    "WD_cwm_n" = "Stem specific wood \n density (g cm-3)"
  )
  aggr_fig(data_aggr, var_names,
    title_fig = "Functional composition across Plots and Years"
  )
}
```
### Functional composition of fluxes

We estimated the functional composition of fluxes as the functional trait value of each stem weighted by its contribution to a given flux (recruitment, growth or mortality). We quantified the fluxes in basal area, but it could be done in other ways (e.g. in AGB, stem abundance, etc). 

```{r functional-composition-ba-recr}
#| message: false
#| warning: false

ba_func <- function(x) pi * (x / 200)**2
data_aggr <- data_cor |>
  filter(!is.na(prev_year) & Year == recr_year) |>
  inner_join(
    read.delim("data/derived_data/traits_v6.tsv"),
    by = "scientific_cleaned"
  ) |>
  filter(!is.na(genus_trait_value_imputed)) |>
  group_by(Site, Plot,
    Year = year_census,
    variable = paste0(trait, "_cwm_rba")
  ) |>
  reframe(value = exp(weighted.mean(
    log(genus_trait_value_imputed),
    ba_func(diameter_cor) / (Year - prev_year)
  ))) |>
  rbind(data_aggr)
```

```{r fig-cwm-ba-recr}
#| message: false
#| warning: false
#| fig.height: 6
#| fig.width: 8

if (isTRUE(params$print)) {
  var_names <- c(
    "LA_cwm_rba" = "Leaf area (mm2)",
    "N_cwm_rba" = "Leaf nitrogen content \n per leaf dry mass \n (mg g-1)",
    "SLA_cwm_rba" = "Specific leaf area \n (mm2 mg-1)",
    "WD_cwm_rba" = "Stem specific wood \n density (g cm-3)"
  )
  aggr_fig(data_aggr, var_names,
    title_fig = "Functional composition\nweighted by recruitment in BA"
  )
}
```

```{r functional-composition-ba-growth}
#| message: false
#| warning: false

data_aggr <- data_cor |>
  mutate(ba_growth = ba_func(diameter_cor - diam_growth + diam_growth_cor) -
    ba_func(diameter_cor - diam_growth)) |> # nolint
  filter(!is.na(ba_growth)) |>
  inner_join(
    read.delim("data/derived_data/traits_v6.tsv"),
    by = "scientific_cleaned"
  ) |>
  filter(!is.na(genus_trait_value_imputed)) |>
  group_by(Site, Plot,
    Year = year_census,
    variable = paste0(trait, "_cwm_gba")
  ) |>
  reframe(value = exp(weighted.mean(
    log(genus_trait_value_imputed),
    ba_growth
  ))) |>
  rbind(data_aggr)
```

```{r fig-cwm-ba-growth}
#| message: false
#| warning: false
#| fig.height: 6
#| fig.width: 8

if (isTRUE(params$print)) {
  var_names <- c(
    "LA_cwm_gba" = "Leaf area (mm2)",
    "N_cwm_gba" = "Leaf nitrogen content \n per leaf dry mass \n (mg g-1)",
    "SLA_cwm_gba" = "Specific leaf area \n (mm2 mg-1)",
    "WD_cwm_gba" = "Stem specific wood \n density (g cm-3)"
  )
  aggr_fig(data_aggr, var_names,
    title_fig = "Functional composition\nweighted by growth in BA"
  )
}
```

```{r functional-composition-ba-mort}
#| message: false
#| warning: false

data_aggr <- data_cor |>
  filter(Year == mort_year) |>
  mutate(ba_mort = ba_func(diameter_cor) / (next_census - Year)) |>
  mutate(Year = next_census) |>
  inner_join(
    read.delim("data/derived_data/traits_v6.tsv"),
    by = "scientific_cleaned"
  ) |>
  filter(!is.na(genus_trait_value_imputed)) |>
  group_by(Site, Plot, Year, variable = paste0(trait, "_cwm_mba")) |>
  reframe(value = exp(weighted.mean(
    log(genus_trait_value_imputed),
    ba_mort
  ))) |>
  rbind(data_aggr)
```


```{r fig-cwm-ba-mort}
#| message: false
#| warning: false
#| fig.height: 6
#| fig.width: 8

if (isTRUE(params$print)) {
  var_names <- c(
    "LA_cwm_mba" = "Leaf area (mm2)",
    "N_cwm_mba" = "Leaf nitrogen content \n per leaf dry mass \n (mg g-1)",
    "SLA_cwm_mba" = "Specific leaf area \n (mm2 mg-1)",
    "WD_cwm_mba" = "Stem specific wood \n density (g cm-3)"
  )
  aggr_fig(data_aggr, var_names,
    title_fig = "Functional composition\nweighted by mortality in BA"
  )
}
```

#### Contribution of fluxes to functional composition changes

```{r contribution-cwm-ba-fluxes}
#| message: false
#| warning: false

if (params$site %in% c("mbaiki", "paracou")) {
  data_temp <- data_cor |>
    mutate(year_census = next_census, ba_prev = ba_func(diameter_cor)) |>
    select(Site, Plot, IdStem, scientific_cleaned, year_census, ba_prev) |>
    full_join(data_cor) |>
    filter(!is.na(year_census)) |>
    mutate(Year = year_census, ba = ba_func(diameter_cor)) |>
    mutate(group = ifelse(is.na(ba_prev), "rba",
      ifelse(is.na(ba), "mba", "gba")
    )) |>
    mutate(ba = ifelse(is.na(ba), 0, ba))

  data_all <- data_temp |>
    inner_join(
      read.delim("data/derived_data/traits_v6.tsv"),
      by = "scientific_cleaned"
    ) |>
    group_by(Site, Plot, Year, trait) |>
    summarise(
      ba_tot = sum(ba), ba_prev_tot = sum(ba_prev, na.rm = TRUE),
      cwm_tot = sum(genus_trait_value_imputed * ba, na.rm = TRUE) / sum(ba)
    ) |>
    # change cwm_tot to be the year before the inventory,
    # to standardize contributions as the change compared to the previous year
    group_by(Site, Plot, trait) |>
    mutate(cwm_tot = c(NA, cwm_tot[-length(cwm_tot)]))
  data_temp <- data_temp |>
    inner_join(
      read.delim("data/derived_data/traits_v6.tsv"),
      by = "scientific_cleaned"
    ) |>
    left_join(data_all) |>
    group_by(Site, Plot, Year, trait, group) |>
    summarise(
      cwm = sum(ba * (genus_trait_value_imputed - cwm_tot), na.rm = TRUE),
      cwm_prev = sum(ba_prev * (genus_trait_value_imputed - cwm_tot),
        na.rm = TRUE
      )
    ) |>
    left_join(data_all) |>
    mutate(value = cwm / ba_tot - cwm_prev / ba_prev_tot) |>
    filter(!is.na(value))
  data_aggr <- data_temp |>
    group_by(Site, Plot, Year, trait) |>
    summarise(value = sum(value), group = "all") |>
    bind_rows(data_temp) |>
    mutate(variable = paste0(trait, "_cwmdiff_", group)) |>
    select(Site, Plot, Year, variable, value) |>
    bind_rows(data_aggr)
  rm(data_temp, data_ba)
}
```

### Functional variance

Based on the functional trait values mentioned in the previous section, we calculated the variance of every functional trait. 

The following figures represent all the above mentioned indices. The y axis shows the different census years, while the x-axis shows the value of the indices. The different coloured lines represent the plots.


```{r functional-var}
#| message: false
#| warning: false
data_aggr <- data_cor |>
  group_by(Site, Plot, Year = year_census, scientific_cleaned) |>
  inner_join(
    read.delim("data/derived_data/traits_v6.tsv"),
    by = "scientific_cleaned"
  ) |>
  filter(!is.na(genus_trait_value_imputed)) |>
  group_by(Site, Plot, Year, variable = paste0(trait, "_cwv_n")) |>
  reframe(value = var(log(genus_trait_value_imputed))) |>
  rbind(data_aggr)
```

```{r fig-functional-var}
#| message: false
#| warning: false
#| fig.height: 6
#| fig.width: 8

if (isTRUE(params$print)) {
  var_names <- c(
    "LA_cwv_n" = "Leaf area (mm2)",
    "N_cwv_n" = "Leaf nitrogen content \n per leaf dry mass \n (mg g-1)",
    "SLA_cwv_n" = "Specific leaf area \n (mm2 mg-1)",
    "WD_cwv_n" = "Stem specific wood \n density (g cm-3)"
  )
  aggr_fig(data_aggr, var_names,
    title_fig = "Variance of log-transformed Functional Traits"
  )
}
```

### Functional diversity

```{r functional-div}
#| message: false
#| warning: false
traits_used <- c("WD", "SLA", "LA", "N")
matrix_trait <- read.delim("data/derived_data/traits_v6.tsv") |>
  subset(scientific_cleaned %in% data_cor$scientific_cleaned) |>
  subset(trait %in% traits_used) |>
  mutate(log_trait_value_imputed = log(genus_trait_value_imputed)) |>
  pivot_wider(
    id_cols = "scientific_cleaned",
    names_from = trait,
    values_from = log_trait_value_imputed
  ) |>
  column_to_rownames("scientific_cleaned") |>
  as.matrix()

matrix_abund <- data_cor %>%
  subset(!is.na(scientific_cleaned)) %>%
  group_by(
    meas_id = paste(Site, Plot, year_census, sep = "__"),
    scientific_cleaned
  ) %>%
  summarise(count = n(), .groups = "drop") |>
  pivot_wider(
    id_cols = "meas_id",
    names_from = scientific_cleaned,
    values_from = count,
    values_fill = 0
  ) |>
  column_to_rownames("meas_id") |>
  as.matrix()

data_aggr <-
  fd_fric(matrix_trait, matrix_abund, stand = TRUE) |>
  merge(fd_fdiv(matrix_trait, matrix_abund)) |>
  merge(fd_feve(matrix_trait, matrix_abund)) |>
  merge(fd_fdis(matrix_trait, matrix_abund)) |>
  separate(site, c("Site", "Plot", "Year"), sep = "__") |>
  mutate(Year = as.numeric(Year)) |>
  pivot_longer(starts_with("F"), names_to = "variable") |>
  rbind(data_aggr)
```

To describe the variation and structure of traits within communities, we used the above functional traits `r traits_used` to calculate multiple complementary functional diversity indices. These indices capture different dimensions of diversity within trait space, based on species positions and abundances:

#### Functional Richness (scaled)
Measures the volume of trait space occupied by the community, standardized for comparability. It reflects the range of functional strategies present, regardless of species abundance.

#### Functional Divergence
Indicates how abundance is distributed toward the edges of trait space. Higher values suggest that dominant species are functionally distinct from the community centroid, promoting niche differentiation.

#### Functional Evenness
Quantifies the regularity of species spacing and abundance distribution within trait space. High evenness implies that trait values are uniformly distributed and that resource use is balanced.

#### Functional Dispersion
Represents the mean distance of individual species to the communitys trait centroid, weighted by abundance. It accounts for both the spread and distribution of traits and is sensitive to both richness and dominance.

The following figures represent all the above mentioned indices. The y axis shows the different census years, while the x-axis shows the value of the indices. The different coloured lines represent the plots.


```{r fig-functional-div}
#| message: false
#| warning: false
#| fig.height: 6
#| fig.width: 8

if (isTRUE(params$print)) {
  var_names <- c(
    "FRic" = "Functional Richness (scaled)",
    "FDiv" = "Functional Divergence",
    "FEve" = "Functional Evenness",
    "FDis" = "Functional Dispersion"
  )
  aggr_fig(data_aggr, var_names,
    title_fig = "Functional Indices Across Plots and Years"
  )
}
```

These indices provide a comprehensive understanding of how functionally diverse or redundant communities are, and how trait variability may influence ecosystem processes.

```{r taxo-undet, echo=FALSE}
#| message: false
#| warning: false
# add information on percentage of undetermined species
data_aggr <- data_cor |>
  group_by(Site, Plot, Year = year_census) |>
  summarise(
    p_undet_spp = sum(is.na(species_cleaned)) / n(),
    p_undet_gen = sum(is.na(genus_cleaned)) / n(),
  ) |>
  pivot_longer(starts_with("p_undet"), names_to = "variable") |>
  rbind(data_aggr)
```

```{r functional-undet}
#| message: false
#| warning: false
data_aggr <- data_cor |>
  group_by(Site, Plot, Year = year_census, scientific_cleaned) |>
  reframe(ba = (diameter_cor / 200)^2 * pi) |>
  merge(
    read.delim("data/derived_data/traits_v6.tsv"),
    by = "scientific_cleaned"
  ) |>
  group_by(Site, Plot, Year, variable = paste0("p_imputed_", trait)) |>
  reframe(
    value = 1 - sum(!is.na(species_trait_value_raw)) /
      sum(!is.na(genus_trait_value_imputed))
  ) |>
  rbind(data_aggr)
```

## Structural Composition and Diversity

To assess the physical structure of forest communities, we quantified a range of metrics describing structural composition, diversity, and dynamics. These indicators reflect differences in size distribution, biomass, and demographic processes, offering insights into forest development, competition, and disturbance regimes.

```{r gini-coef}
#| message: false
#| warning: false
# as coded in package DescTools
gini <- function(x, w = NULL, unbiased = TRUE) {
  x <- x[!is.na(x)]
  if (is.null(w)) w <- rep(1, length(x))
  w <- w / sum(w)
  x <- x[id <- order(x)]
  w <- w[id]
  f_hat <- w / 2 + c(0, head(cumsum(w), -1))
  wm <- weighted.mean(x, w)
  res <- 2 / wm * sum(w * (x - wm) * (f_hat - weighted.mean(f_hat, w)))
  if (unbiased) {
    res <- res * 1 / (1 - sum(w^2))
  }
  return(res)
}

data_aggr <- data_cor |>
  group_by(Site, Plot, Year = year_census) |>
  summarise(variable = "gini", value = gini(diameter_cor)) |>
  rbind(data_aggr)
```

```{r dbh-median}
#| message: false
#| warning: false
data_aggr <- data_cor |>
  group_by(Site, Plot, Year = year_census) |>
  summarise(variable = "dbh_median", value = median(diameter_cor)) |>
  rbind(data_aggr)
```

```{r dbh-mean}
#| message: false
#| warning: false
data_aggr <- data_cor |>
  group_by(Site, Plot, Year = year_census) |>
  summarise(variable = "dbh_mean", value = mean(diameter_cor)) |>
  rbind(data_aggr)
```

```{r dbh-min}
#| message: false
#| warning: false
data_aggr <- data_cor |>
  group_by(Site, Plot, Year = year_census) |>
  summarise(variable = "dbh_min", value = min(diameter_cor)) |>
  rbind(data_aggr)
```

```{r dbh-max}
#| message: false
#| warning: false
data_aggr <- data_cor |>
  group_by(Site, Plot, Year = year_census) |>
  summarise(variable = "dbh_max", value = max(diameter_cor)) |>
  rbind(data_aggr)
```

We characterized the size structure of the tree community using maximum, minimum, mean and median of the DBH, reflecting the general size of individuals.

We also calculated the Gini coefficient, a widely used measure of inequality adapted to forest structure. In this context, the Gini index measures inequality in stem diameters within a plot: A Gini index of 0 indicates perfect equality, where all trees have the same diameter. A Gini index closer to 1 reflects high inequality, where tree size is concentrated among a few individuals.

The following figures represent all the above mentioned indices. The y axis shows the different census years, while the x-axis shows the value of the indices. The different coloured lines represent the plots.

```{r display-structural-div}
#| message: false
#| warning: false
#| fig.width: 8
#| fig.height: 6

if (isTRUE(params$print)) {
  var_names <- c(
    "gini" = "Gini coefficient", "dbh_median" = "Median DBH (cm)",
    "dbh_mean" = "Mean  DBH (cm))", "dbh_min" = "Min DBH (cm)",
    "dbh_max" = "Max DBH (cm)"
  )
  aggr_fig(data_aggr, var_names,
    title_fig = "Structural composition Across Plots and Years"
  )
}
```

### Stem abundance

To capture temporal changes in forest structure, we calculated the stem abundance, as well as the recruiment and mortality.

The following figures represent the stem abundances and demographic rates. The y axis shows the different census years, while the x-axis shows the value of the indices. The different coloured lines represent the plots.

```{r stem-abundance}
#| message: false
#| warning: false
data_aggr <-
  data_cor |>
  group_by(Site, Plot, Year = year_census) |>
  summarise(
    nstem = n() / unique(PlotArea)
  ) |>
  pivot_longer(nstem, names_to = "variable") |>
  rbind(data_aggr)
```

```{r stem-recruitment}
#| message: false
#| warning: false
data_aggr <- data_cor |>
  mutate(recr = ifelse(Year == recr_year, 1 / (Year - prev_census), 0)) |>
  group_by(Site, Plot, Year = year_census) |>
  summarise(nstem_recr = sum(recr / PlotArea)) |>
  pivot_longer(nstem_recr, names_to = "variable") |>
  rbind(data_aggr)
```

```{r stem-mort}
#| message: false
#| warning: false
data_aggr <- data_cor |>
  subset(Year == mort_year) |>
  group_by(Site, Plot, Year = year_census, next_census) |>
  summarise(nstem_mort = sum(1 / (next_census - Year) / unique(PlotArea))) |>
  mutate(Year = next_census) |>
  subset(!is.na(Year)) |>
  ungroup() |>
  select(Site, Plot, Year, nstem_mort) |>
  pivot_longer(nstem_mort, names_to = "variable") |>
  rbind(data_aggr)
```

```{r plot-stem}
#| message: false
#| warning: false
#| fig.width: 8
#| fig.height: 3

if (isTRUE(params$print)) {
  var_names <- c(
    "nstem" = "Stem abundance (/ha)",
    "nstem_recr" = "Stem recruitment rate (/ha/yr)",
    "nstem_mort" = "Stem mortality rate (/ha/yr)"
  )
  aggr_fig(data_aggr, var_names,
    title_fig = "Demographic rates Across Plots and Years"
  )
}
```

### Basal Area (BA)

In addition, we assessed basal area (BA) and above-ground biomass (AGB) stocks, as well as the BA and AGB contributions in recruitment, growth and mortality, to track structural development and resource accumulation.

The following figures represent the different BAand AGB related indices. The y axis shows the different census years, while the x-axis shows the value of the indices. The different coloured lines represent the plots.

```{r ba}
#| message: false
#| warning: false
ba_func <- function(x) pi * (x / 200)**2
data_cor <- data_cor |>
  mutate(
    ba = ba_func(diameter_cor),
    ba_growth = ba_func(diameter_cor - diam_growth + diam_growth_cor) -
      ba_func(diameter_cor - diam_growth)
  )
```

```{r ba-stock}
#| message: false
#| warning: false
data_aggr <-
  data_cor |>
  group_by(Site, Plot, Year = year_census) |>
  summarise(
    ba = sum(ba / PlotArea)
  ) |>
  pivot_longer(ba, names_to = "variable") |>
  rbind(data_aggr)
```

```{r ba-recr}
#| message: false
#| warning: false
data_aggr <- data_cor |>
  # ba recruitment per tree
  mutate(recr = ifelse(Year == recr_year,
    ba / (year_census - prev_census),
    0
  )) |>
  group_by(Site, Plot, Year) |>
  summarise(ba_recr = sum(recr / PlotArea)) |>
  pivot_longer(ba_recr, names_to = "variable") |>
  rbind(data_aggr)
```

```{r ba-growth}
#| message: false
#| warning: false
data_aggr <- data_cor |>
  subset(!is.na(ba_growth)) |>
  mutate(ba_gr_yr = ba_growth) |>
  group_by(Site, Plot, Year = year_census) |>
  summarise(ba_growth = sum(ba_gr_yr / PlotArea)) |>
  pivot_longer(ba_growth, names_to = "variable") |>
  rbind(data_aggr)
```

```{r ba-mort}
#| message: false
#| warning: false
data_aggr <- data_cor |>
  subset(year_census == mort_year) |>
  group_by(Site, Plot, Year = year_census, next_census) |>
  summarise(ba_mort = sum(ba / (next_census - Year) / PlotArea)) |>
  mutate(Year = next_census) |>
  subset(!is.na(Year)) |>
  select(Site, Plot, Year, ba_mort) |>
  pivot_longer(ba_mort, names_to = "variable") |>
  rbind(data_aggr)
```

```{r fig-ba}
#| message: false
#| warning: false
#| fig.width: 8
#| fig.height: 6

if (isTRUE(params$print)) {
  var_names <- c(
    "ba" = "Basal area (m2/ha)",
    "ba_recr" = "BA recruitment (m2/ha/yr)",
    "ba_growth" = "BA growth (m2/ha/yr)",
    "ba_mort" = "BA mortality (m2/ha/yr)"
  )
  aggr_fig(data_aggr, var_names,
    title_fig = "Basal area dynamics"
  )
}
```

### Aboveground biomass (AGB)

We used equation 7 from Chave et al. (2014) to estimate tree-level aboveground biomass.

```{r add-wd}
#| message: false
#| warning: false
# add wood density
data_cor <- read.delim("data/derived_data/traits_v6.tsv") |>
  subset(trait == "WD") |>
  mutate(WD = ifelse(is.na(species_trait_value_raw),
    genus_trait_value_imputed,
    species_trait_value_raw
  )) |>
  select(scientific_cleaned, WD) |>
  right_join(data_cor)

p_na_wd <- round(sum(is.na(data_cor$WD)) / nrow(data_cor) * 100, 1)
data_cor <- data_cor |>
  group_by(Site, Plot, Year) |>
  mutate(WD = ifelse(is.na(WD), mean(WD, na.rm = TRUE), WD)) %>%
  group_by(Site, Year) |>
  mutate(WD = ifelse(is.na(WD), mean(WD, na.rm = TRUE), WD)) %>%
  group_by(Site) |>
  mutate(WD = ifelse(is.na(WD), mean(WD, na.rm = TRUE), WD))

if (any(is.na(data_cor$WD))) {
  stop("NA in WD")
}
```

We used imputed specific wood density values; for individuals that were not identified to the species (`r p_na_wd`%), we use an average wood density value per plot and census year.

```{r agb}
#| message: false
#| warning: false
agb_func <- function(d, wd, e_var) {
  return(exp(-2.023977 - 0.89563505 * e_var + 0.92023559 * log(wd) +
    2.79495823 * log(d) - 0.04606298 * (log(d)^2)) / 1000) # nolint
}
data_cor <- data_cor |>
  mutate(
    agb = agb_func(diameter_cor, WD, e),
    agb_growth = agb_func(diameter_cor - diam_growth + diam_growth_cor, WD, e) -
      agb_func(diameter_cor - diam_growth, WD, e)
  )
if (any(is.na(data_cor$agb))) {
  stop("NA in AGB values")
}
```

```{r agb-stocks}
#| message: false
#| warning: false
data_aggr <-
  data_cor |>
  group_by(Site, Plot, Year = year_census) |>
  summarise(
    agb = sum(agb / PlotArea)
  ) |>
  pivot_longer(agb, names_to = "variable") |>
  rbind(data_aggr)
```

```{r agb-recr}
#| message: false
#| warning: false
data_aggr <- data_cor |>
  # agb recruitment per tree
  mutate(recr = ifelse(year_census == recr_year,
    agb / (year_census - prev_census), 0
  )) |>
  group_by(Site, Plot, Year = year_census) |>
  summarise(agb_recr = sum(recr / PlotArea)) |>
  pivot_longer(agb_recr, names_to = "variable") |>
  rbind(data_aggr)
```

```{r agb_growth}
#| message: false
#| warning: false
data_aggr <- data_cor |>
  subset(!is.na(agb_growth)) |>
  mutate(agb_gr_yr = agb_growth) |>
  group_by(Site, Plot, Year = year_census) |>
  summarise(agb_growth = sum(agb_gr_yr / PlotArea)) |>
  pivot_longer(agb_growth, names_to = "variable") |>
  rbind(data_aggr)
```

```{r agb-mort}
#| message: false
#| warning: false
data_aggr <- data_cor |>
  subset(Year == mort_year) |>
  group_by(Site, Plot, Year = year_census, next_census) |>
  summarise(agb_mort = sum(agb / (next_census - Year) / PlotArea)) |>
  mutate(Year = next_census) |>
  subset(!is.na(Year)) |>
  select(Site, Plot, Year, agb_mort) |>
  pivot_longer(agb_mort, names_to = "variable") |>
  rbind(data_aggr)
```

```{r fig-agb}
#| message: false
#| warning: false
#| fig.width: 8
#| fig.height: 6

if (isTRUE(params$print)) {
  var_names <- c(
    "agb" = "AGB (t/ha)",
    "agb_recr" = "AGB recruitment (t/ha/yr)",
    "agb_growth" = "AGB growth (t/ha/yr)",
    "agb_mort" = "AGB mortality (t/ha/yr)"
  )
  aggr_fig(data_aggr, var_names,
    title_fig = "Aboveground biomass dynamics"
  )
}
```

# Conclusion

All the aggregated data generated is stored in a csv file, which will further be used for analysis in the Bioforest project.

```{r save-aggregated-data}
data_aggr |>
  write.csv(paste0(
    "data/derived_data/aggregated_data_",
    params$site,
    ".csv"
  ), row.names = FALSE)
```

```{r save-plot-area}
#| message: false
#| warning: false
data_cor |>
  select(Site, Plot, PlotArea) |>
  unique() |>
  write.csv(paste0(
    "data/derived_data/plot_area_",
    params$site,
    ".csv"
  ), row.names = FALSE)
```
