---
title: "Data aggregation"
format:
  pdf:
    toc: true
    number-sections: true
    colorlinks: true
params: 
  site: ecosilva
  taper: false
  plot_filter: false
  plot: "Manare_I"

execute:
  echo: false      
---


```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file(),
                      warning = FALSE, message = FALSE,  results = "hide") 

library(data.table)
library(BIOMASS)
library(ggplot2)
library(tidyverse)
library(entropart)
library(fundiversity)
library(patchwork)
```

# Introduction

This document is made to be used by data contributors of the Bioforest project, which is an initiative of the TmFO network. By running this quarto document, you will be able to visualize various aspects of your data, and generate an aggregated data set as output. This aggregated data set (depending on the variables available) will be used for analysis by various working groups in the Bioforest project.

Before you run this quarto script, please make sure that you complete the following checklist, and ensure the your dataset is named and structured correctly to be able to run this script.

You should have already:

-   signed the data agreement;

-   harmonized your **raw** dataset using the [DataHarmonization app](https://github.com/Alliance-for-Tropical-Forest-Science/DataHarmonization); the harmonized dataset should be placed in the same folder as this file;

-   sent us your species list;

-   added plot-level information to this [document](https://docs.google.com/spreadsheets/d/1fq2owxMBLBwwibcdw2uQQFxnIhsMbaH4Qcj_xUwVvSQ/edit?usp=drive_link).

-   made sure all input files are in the same folder

```{r load-data, echo=FALSE}
# automate compilation for all sites with qmd params
data_list <- list.files("data/raw_data/", params$site, full.names = TRUE)
if (length(data_list) == 0) {
  stop("Please check that the site name in params matches your data file name.")
}

# importing site names corrections table
sites <- read.csv("data/raw_data/site_name_correction.csv") |>
  separate_rows(site_raw, sep = ",") |>
  unique()

# creating a taxonomic ID to use for joining wrong and corrected taxa
read_harmonized <- function(file) {
  cols <- c(
    ScientificName = NA_character_,
    VernName = NA_character_,
    Family = NA_character_,
    Genus = NA_character_,
    Species = NA_character_
  )
  read_csv(file,
    locale = readr::locale(encoding = "latin1"),
    col_types = cols()
  ) %>%
    add_column(!!!cols[!names(cols) %in% names(.)]) %>%
    mutate(raw_taxonomy = paste(
      ScientificName, "-", VernName, "-",
      Family, Genus, Species)) %>% 
    mutate(file = gsub("../inventories/data/raw_data/", "", file))
}



# extracting data file and creating consistent site names
data_raw <-
  data_list |>
  # rbindlist(fill = TRUE, use.names = TRUE) |>
  lapply(read_harmonized) |>
  bind_rows() |>
  mutate(Site = as.character(Site)) |>
  rename(site_raw = Site) |>
  left_join(sites) |>
  select(-site_raw) |>
  rename(Site = site) |>
  mutate(Plot = as.character(Plot))

if (params$plot_filter) {
  data_raw <- filter(data_raw, Plot == params$plot)
}
```

```{r create-data-cor}
data_cor <- data_raw
```

```{r merge-cleaned-taxonomy}
data_species <-
  read_tsv("data/derived_data/taxonomy_v4.tsv") |>
  #select(contains("cleaned") | "tax_id" | "file") |>
  unique()

#if (!all(unique(data_cor$raw_taxonomy) %in% unique(data_species$raw_taxonomy))) {
#  stop("This file does not have clean taxonomy")
#}

data_cor <- data_cor |>
  left_join(data_species, by = c("raw_taxonomy"))

```

```{r remove-values}
# some values (partial censuses, etc) need to be removed in some sites
text <- ""
if (any(data_raw$Site == "Paracou")) {
  data_cor <- data_cor |>
    subset(!(Site == "Paracou" & as.numeric(Plot) == 16)) |>
    subset(!(Site == "Paracou" & (Year %in% c(1996, 1998, 2000, 2002)))) |>
    subset(!(Site == "Paracou" & Year == 2010 & Plot == 15))
  text <- paste(
    text,
    "In Paracou, we removed partial census years: 1996, 1998, 2000, and 2002,",
    "and census year 2010 of plot 15 (25% of the plot was not measured)."
  )
}
```

`r text`

```{r add-plot-level-data}
# download from google drive
if (!file.exists("data/raw_data/bioforest-plot-information.csv")) {
  googledrive::drive_get(
    googledrive::as_id("1fq2owxMBLBwwibcdw2uQQFxnIhsMbaH4Qcj_xUwVvSQ")
  ) |>
    googledrive::drive_download(
      path = "data/raw_data/bioforest-plot-information",
      type = "csv", overwrite = TRUE
    )
  # TODO solve authentication error
}
plot_information <- read.csv("data/raw_data/bioforest-plot-information.csv") |>
  mutate(site = as.character(site)) |>
  rename(site_raw = site) |>
  left_join(sites) |>
  select(-site_raw) |>
  subset(site %in% unique(data_cor$Site))
```

```{r add-missing-plot-coordinates}
# temporarily add plot information when missing online
plot_information <- plot_information |>
  # temporary: some plots in MBaiki have the switched coordinates
  mutate(
    latitude_cor = ifelse(site == "Mbaiki" & latitude > 4, longitude, latitude),
    longitude_cor = ifelse(site == "Mbaiki" & latitude > 4, latitude, longitude)
  ) |>
  # remove "subplot" from Tene data
  mutate(plot = gsub("Subplot_", "", plot))
```

```{r add-e-var}
# add E variable for AGB allometry (from Chave et al 2014)
plot_information <- plot_information |>
  mutate(e = computeE(cbind(longitude_cor, latitude_cor)))
```

```{r harmonize-treatment-info}
# harmonize treatment information as logging and silvicultural treatments (T/F)
control_string <- "control"
silv_string <- "treatment|devital|thinning"
plot_information <- plot_information |>
  mutate(
    Treatment = ifelse(Treatment != "", Treatment, NA),
    logging = !grepl(control_string, tolower(Treatment)),
    silv_treat = grepl(silv_string, tolower(Treatment))
  ) |>
  ## remove plots that don't have coordinates and treatment information
  subset(!is.na(longitude)) |>
  select(site, plot, longitude, latitude, logging, silv_treat, e, Treatment)
```

```{r remove-plots-without-coords}
# plots that are not on the online document
data_missing <- data_cor |>
  mutate(site = Site, plot = Plot) |>
  select(site, plot, PlotArea) |>
  unique() |>
  merge(plot_information, all = TRUE) |>
  subset(is.na(longitude) | is.na(PlotArea)) |>
  mutate(idplot = paste(site, plot, sep = "-"))

# add plot-level information to the table
data_cor <- data_cor |>
  merge(plot_information,
    by.x = c("Site", "Plot"), by.y = c("site", "plot")
  ) |>
  mutate(Plot = paste(Site, Plot, Treatment,
    sep = "-"
  ))

missing <- paste(subset(data_missing, is.na(longitude))$idplot, collapse = ", ")

text <- ifelse(
  nchar(missing) > 0,
  paste0(
    "The following plots have missing coordinates and have been removed from",
    "the analysis: ", missing, "."
  ),
  "All plots have coordinates."
)
if (nrow(data_cor) == 0) {
  stop(paste0(
    "Please check the information (coordinates and treatment) ",
    "on the online document: https://docs.google.com/spreadsheets/d/1fq2owxMBLBwwibcdw2uQQFxnIhsMbaH4Qcj_xUwVvSQ/edit?usp=drive_link" # nolint
  ))
}
```

`r text`

If needed, you can add any missing information to the [online document](https://docs.google.com/spreadsheets/d/1fq2owxMBLBwwibcdw2uQQFxnIhsMbaH4Qcj_xUwVvSQ/edit?usp=drive_link) or check that the site and plot names are consistent between your harmonized data and the online document.

# General presentation of the data

This document presents the data aggregation for the `r paste(unique(data_cor$Site), collapse = ", ")` site(s). The site(s) have `r length(unique(data_cor$Plot))` plots: `r unique(data_cor$Plot)`

It has `r dim(data_cor)[1]` observations, belonging to `r length(unique(data_cor$IdStem))` stems.

The following table shows the number of censuses per plots, the first and last year of census, and the number of individuals measured in each census.

```{r show-census-count}
data_cor %>%
  group_by(Site, Plot) %>%
  summarise(number_of_censuses = length(unique(IdCensus)),
            first_census = min(Year),
            last_census = max(Year),
            num_individuals = n_distinct(IdStem)) %>%
  knitr::kable(col.names = c("Site", "Plot", "Number of censuses", 
                             "First census", "Last census", 
                             "Number of individuals"))
```

Censuses were conducted between `r min(data_cor$Year)` and `r max(data_cor$Year)`.

*Please let us know if there are missing plots or censuses.*

# Check data consistency

This step checks for the absence of "anomalies" in the data.

## Avoid duplicated measurements

We paste the name of the site, plot, subplot and tag/ID of the tree and stem to create a new unique identifier for each stem.

```{r complete-idstem}
data_cor <- data_cor |>
  mutate(IdStem = paste(Site, Plot, Subplot, IdTree, IdStem, sep = "_"))
```

We then check that there are no duplicated measurements for the same stem ID in a given census.

```{r print-duplicated-stems}
nb_stem_plot <- data_cor %>%
  count(IdStem, IdCensus)

if (all(length(unique(nb_stem_plot$n)) == 1, unique(nb_stem_plot$n) == 1)) {
  text <- "There is no duplicated stem identifiers within a same census."
} else {
  stem_dupli <- nb_stem_plot %>%
    filter(n > 1)
  text <- paste("There are ",
    dim(stem_dupli)[1],
    " cases of duplicated stem identifiers within a same census,",
    " with a number of duplications ranging from ",
    stem_dupli %>% summarise(min(n)),
    " and ",
    stem_dupli %>% summarise(max(n)),
    " (mean = ",
    stem_dupli %>% summarise(round(mean(n), 2)),
    "). These duplications concern ",
    length(unique(stem_dupli$IdStem)),
    " stems.",
    sep = ""
  )
}
```

`r text`

```{r rmv-full-duplicated-stems}
if (length(unique(nb_stem_plot$n)) != 1) { # if there are some duplicates
  prev_nb_obs <- dim(data_cor)[1]
  data_cor <- data_cor %>% distinct() # remove fully duplicated rows
  # if there were some fully duplicated rows:
  if (prev_nb_obs - dim(data_cor)[1] != 0) {
    text <- paste(
      prev_nb_obs - dim(data_cor)[1],
      "rows are true duplicates (fully identical rows).",
      "These true duplicates are removed from the dataset,",
      "leaving a dataset of", dim(data_cor)[1], "observations."
    )
  } else {
    text <- ""
  }
  nb_stem_plot_bis <- data_cor %>%
    count(IdStem, IdCensus)
} else { # if no duplicated rows
  text <- ""
}
```

`r text`

```{r remaining-duplicated-stems}
if (length(unique(nb_stem_plot$n)) != 1) { # if there are some duplicates
  if (all(
    length(unique(nb_stem_plot_bis$n)) == 1,
    unique(nb_stem_plot_bis$n) == 1
  )) {
    text <- "There is no more duplicated stem identifiers within a same census."
    still_stem_dupli <- FALSE
  } else {
    stem_dupli_bis <- nb_stem_plot_bis %>%
      filter(n > 1)
    text <- paste(
      "There are still",
      dim(stem_dupli_bis)[1],
      "cases of duplicated stem identifiers within a same census,",
      "which are not fully replicated rows.",
      "This concern the following cases:"
    )
    still_stem_dupli <- TRUE
  }
} else {
  still_stem_dupli <- FALSE
}
```

`r text`

```{r print-remaining-duplicated-stems}
if (still_stem_dupli == TRUE) {
  stem_dupli_bis %>%
    select(IdStem, IdCensus) %>%
    knitr::kable()
}
```

```{r warn-remaining-duplicated-stems}
if (still_stem_dupli == TRUE) {
  text <- paste(
    "IMPORTANT: Please check these cases in your raw data before starting the",
    "process again. For now, we have only kept the first measurement of these",
    "duplicate stems, but please let us know how we can better deal with these",
    "duplicate measurements."
  )
  data_cor <- data_cor |>
    subset(!duplicated(paste(IdStem, IdCensus)))
} else {
  text <- ""
}
```

`r text`

## Are there multi-stemmed trees?

```{r check-multi-stems}
#| message: false
#| warning: false
data_nstem <- data_cor |>
  group_by(Site, Plot, Subplot, IdTree) |>
  summarise(nstem = length(unique(IdStem)))
if (all(data_nstem$nstem == 1)) {
  text <- paste(
    "The number of stem identifiers and the number of tree identifiers are",
    "equal, suggesting either that there are no multi-stemmed trees, or",
    "that the multiple stems are considered as different individuals."
  )
} else {
  text <- "The following trees have multiple stems:"
}
```

`r text`

```{r}
if (any(data_nstem$nstem != 1)) {
  data_nstem |>
    subset(nstem > 1) |>
    knitr::kable()
}
```

## Consistency of diameter measurements

### Remove missing (NA) DBH values

```{r check-na-dbh}
if (anyNA(data_cor$Diameter)) {
  nb_na_dbh <- sum(is.na(data_cor$Diameter))
  perc_na_dbh <- round(
    sum(is.na(data_cor$Diameter)) * 100 / dim(data_cor)[1],
    2
  )
  text <- paste("There are",
    nb_na_dbh,
    "missing diameters in the data, which represent",
    perc_na_dbh,
    "% of the observations.",
    "The missing values are distributed across the plots",
    "and censuses as follow:",
    sep = " "
  )
} else {
  text <- "There are no missing diameter in the data."
}
```

`r text`

```{r print-na-dbh}
if (anyNA(data_cor$Diameter)) {
  data_cor %>%
    filter(is.na(Diameter)) %>%
    count(Plot, IdCensus) %>%
    pivot_wider(names_from = Plot, values_from = n) %>%
    knitr::kable()
}
```

We first remove all measures with either DBH = 0 cm or NA values.

```{r remove-na-dbh}
data_cor <- data_cor |>
  subset(Diameter > 0 & !is.na(Diameter))
```

### All trees are above the DBH cutoff

```{r get-dbh-cutoff}
#| message: false
#| warning: false
if (length(unique(data_cor$MinDBH)) == 1) {
  text <- paste(
    "There is a single DBH cutoff set to",
    unique(data_cor$MinDBH),
    "cm for the whole data set."
  )
} else {
  # count the number of cutoff > 10 cm per plot and census
  cutoff_plot_cens <- data_cor %>%
    group_by(Site, Plot) %>%
    summarise(n_cutoff_sup_10 = length(unique(MinDBH[MinDBH > 10])))
  if (all(cutoff_plot_cens$n_cutoff_sup_10 == 0)) {
    text <- paste(
      "All DBH cutoffs are at 10 cm or below;",
      "we will only use stems > 10 cm DBH."
    )
  } else {
    data_above_10 <- cutoff_plot_cens |>
      subset(n_cutoff_sup_10 > 0) |>
      mutate(idplot = paste(Site, Plot, sep = "-"))
    text <- paste(
      "The following plots have one or more DBH cutoffs",
      "above 10 cm DBH:",
      paste(data_above_10$idplot, collapse = ", ")
    )
  }
}
```

`r text`

```{r print-dbh-cutoff}
#| message: false
#| warning: false
if (length(unique(data_cor$MinDBH)) != 1) {
  data_cor %>%
    group_by(Site, Plot, IdCensus) %>%
    summarise(dbhcut = unique(MinDBH)) %>%
    # pivot_wider(names_from = Plot, values_from = dbhcut) %>%
    knitr::kable()
}
```

```{r remove-dbh-below-cutoff}
if (with(data_cor, !any(Diameter < MinDBH | Diameter < 10))) {
  text <- "There are no stems with a DBH below the DBH cutoff or below 10 cm."
} else {
  n_below_cut <- with(data_cor, sum(Diameter < MinDBH & !is.na(Diameter)))
  n_below_10 <- with(data_cor, sum(Diameter < 10 & !is.na(Diameter)))

  text <- paste("There are ",
    n_below_cut,
    " observations of stems with a DBH below their DBH cutoff (",
    round(n_below_cut * 100 / dim(data_cor)[1], 2),
    "%), with a difference ranging ",
    subset(data_cor, Diameter < MinDBH) |>
      with(MinDBH - Diameter) |>
      range() |>
      round(3) |>
      paste(collapse = "-"),
    " cm between the observation and the cutoff, and a median difference of ",
    subset(data_cor, Diameter < MinDBH) |>
      with(MinDBH - Diameter) |>
      median() |>
      round(2),
    " cm. There were ",
    n_below_10,
    " observations with a DBH below 10 cm (",
    round(n_below_10 * 100 / dim(data_cor)[1], 1),
    "%). These observations are removed, leaving a dataset of ",
    dim(data_cor)[1],
    " observations.",
    sep = ""
  )
}

data_cor <- data_cor %>% filter(Diameter >= MinDBH & Diameter >= 10)
```

`r text`

### Level of taxonomic resolution

```{r na-sp}
if (anyNA(data_cor$scientific_cleaned)) {
  nb_na_sp <- sum(is.na(data_cor$scientific_cleaned))
  perc_na_sp <- round(
    sum(is.na(data_cor$scientific_cleaned)) * 100 / dim(data_cor)[1], 2
  )
  nb_na_sp_tree <- data_cor %>%
    filter(is.na(scientific_cleaned)) %>%
    summarise((length(unique(IdTree))))
  text <- paste("There are",
    nb_na_sp,
    "observations with NAs in the scientific names, which represent",
    perc_na_sp,
    "% of the observations.
    This concerns",
    nb_na_sp_tree,
    "trees.",
    "The observations with NAs in the scientific names
    are distributed across the plots and censuses as follow:",
    sep = " "
  )
} else {
  text <- "There are no unidentified trees."
}
```

`r text`

```{r display-taxo-resolution}
data_cor |>
  group_by(Site, Plot, Year) |>
  summarise(
    pundet = sum(is.na(genus_cleaned)) / length(genus_cleaned),
    pgenus = sum(!is.na(genus_cleaned) & is.na(species_cleaned))
    / length(genus_cleaned),
    pspecies = sum(!is.na(species_cleaned)) / length(species_cleaned)
  ) |>
  pivot_longer(cols = c("pundet", "pgenus", "pspecies")) |>
  ggplot(aes(Year, value, fill = name)) +
  geom_col() +
  facet_wrap(~Plot) +
  theme_minimal()
```

## Remove measurements other than live trees

### Remove dead trees

```{r remove-dead}
alive <- c(1:4, TRUE, NA, "Normal", "Recruit")
# embrapa sites : CIF <= 5: live trees
if ("LifeStatus" %in% colnames(data_cor)) {
  n_dead <- sum(!data_cor$LifeStatus %in% alive)
  if (n_dead > 0) {
    text <- paste0(
      n_dead, " (", round(n_dead / nrow(data_cor) * 100, 2), "%) measurements",
      " with Diameter > min DBH were considered as dead, and removed from the ",
      "analysis. Their LifeStatus values of trees considered dead were: ",
      paste(unique(
        setdiff(data_cor$LifeStatus, alive)
      ), collapse = ", "),
      "."
    )
  } else {
    text <- paste(
      "No measurements (with Diameter > min DBH) were",
      "identified as dead trees in the data."
    )
  }

  data_cor <- data_cor |> subset(LifeStatus %in% alive)
  # TODO: ask for life status codes per site?
} else {
  text <- paste(
    "There was no column 'LifeStatus' with information about life status",
    "(dead/alive), so we considered all stems to be alive: please let us know",
    "if we should have used another column."
  )
}
```

`r text`

### Remove life forms other than trees (lianas, palms, etc)

```{r select-life-form}
if ("LifeForm" %in% colnames(data_cor)) {
  data_cor <- data_cor |>
    # subsetting to remove life forms other
    subset(!(tolower(LifeForm) %in% c("palm", "tree fan", "death", "vine"))) |>
    # remove palm genera or vernacular names
    subset(family_cleaned != "Arecaceae" | is.na(family_cleaned)) |>
    # Astrocaryum vernacular name in Paracou, only identified to vern name
    subset(is.na(VernName) | VernName != "murumuru")
} else {
  text <- paste(
    "There was no column 'LifeForm' with information about life forms",
    "(such as trees, lianas, palms), so we assume that all individuals",
    "in your dataset are trees. Please let us know if that is not the case."
  )
}
```

## Consistency of stem-level information

### Only one scientific name per tree

This step adds two columns to the dataset:

-   ScientificName_cor : corrected scientific name, see SpName_codecor to know how it was filled.

-   SpName_codecor : the type of correction that has been done:

-   "no_cor" when there was no problem,

-   "gapfilled" observations with NA in the ScientificName, but for which other observations of the same trees have a unique ScientificName. These cases were gapfilled by putting the scientific name of the other observations in ScientificName_cor

-   "more than one scientific name" for observations of individuals with at least 2 different (non NA) scientific names. As we cannot know which is correct, all observations of the given individuals are set to NA.

> To discuss : it would be worth gapfilling the scientific name when some obs are indet. as well, But I don't know if the Inded are always coded the same, and how...


```{r one-sp-per-tree}
nb_sp_tree <- data_cor %>%
  group_by(IdTree) %>%
  summarise(nbsp = length(unique(scientific_cleaned)))

data_cor <- data_cor %>% mutate(
  ScientificName_cor = as.character(NA),
  SpName_codecor = as.factor(NA)
)

# when there is just one scientific name for all the observation of a given tree
tree_no_cor <- nb_sp_tree %>% filter(nbsp == 1)
# use the ScientificNames as the corrected one
data_cor <- data_cor %>%
  mutate(ScientificName_cor = ifelse(IdTree %in% tree_no_cor$IdTree,
    scientific_cleaned,
    ScientificName_cor
  ))
# fill in the code_cor
data_cor <- data_cor %>%
  mutate(SpName_codecor = ifelse(IdTree %in% tree_no_cor$IdTree,
    "no_cor",
    SpName_codecor
  ))

# When there are two scientific names
tree_2_sp <- nb_sp_tree %>% filter(nbsp == 2)
for (i in tree_2_sp$IdTree) {
  names2 <- data_cor %>%
    filter(IdTree == i) %>%
    reframe(names = unique(scientific_cleaned))
  if (any(is.na(names2))) { # if one of the two names is NA
    data_cor <- data_cor %>%
      mutate(ScientificName_cor = ifelse(IdTree == i,
        ifelse(
          is.na(scientific_cleaned), # if NA in Scientific name
          names2[!is.na(names2)], # we use the name of the other obs
          scientific_cleaned
        ), # otherwise, use the name of the current obs
        ScientificName_cor
      )) # do nothing if not the tree of interest
    # fill in the code_cor
    data_cor <- data_cor %>%
      mutate(SpName_codecor = ifelse(IdTree == i,
        ifelse(
          is.na(scientific_cleaned), # if NA in Scientific name
          "gapfilled",
          "no_cor"
        ),
        SpName_codecor
      )) # do nothing if not the tree of interest
  } else { # if none of the two names are NA
    data_cor <- data_cor %>%
      mutate(ScientificName_cor = ifelse(IdTree == i,
        NA, # put NA as we don't know which one is the good one
        ScientificName_cor
      ))
    # fill in the code_cor
    data_cor <- data_cor %>%
      mutate(SpName_codecor = ifelse(IdTree == i,
        "more than one scientific name",
        SpName_codecor
      ))
  }
}

# when there are more than two scientific name for a given tree
tree_many_sp <- nb_sp_tree %>% filter(nbsp > 2)
# replace the name by NA (as we don't know which one is the good one
data_cor <- data_cor %>%
  mutate(ScientificName_cor = ifelse(IdTree %in% tree_many_sp,
    NA,
    ScientificName_cor
  ))
# fill in the code_cor
data_cor <- data_cor %>%
  mutate(SpName_codecor = ifelse(IdTree %in% tree_many_sp,
    "more than one scientific name",
    SpName_codecor
  ))
```

```{r text-sp-dupl}
if (all(data_cor$SpName_codecor == "no_cor")) { # no duplicated names
  text <- paste(
    "There was always only one scientific name for a given individual (or",
    "always a NA). No change has been made. The value is ScientificName_cor",
    "is the same than in scientific_cleaned, and
    SpName_codecor is always 'no_cor'"
  )
} else { # if some correction have been made
  nb_filled <- data_cor %>%
    filter(SpName_codecor == "gapfilled") %>%
    count()
  nb_prob <- data_cor %>%
    filter(SpName_codecor == "more than one scientific name") %>%
    count()
  if (nb_filled != 0) {
    text1 <- paste(
      "There were",
      nb_filled,
      "observations with NA in the scientific_cleaned,
                   but for which other observations of the same trees
                   have a unique scientific_cleaned
                   These case were gapfilled by putting the scientific name
                   of the other observations in ScientificName_cor. The
                   value in SpName_codecor is 'gapfilled'."
    )
  } else {
    text1 <- ""
  }
  if (nb_prob != 0) {
    text2 <- paste(
      "There were",
      nb_prob,
      "observations of individuals with at least 2 different (non NA)
                   scientific names.
                   As we cannot know which is correct,
                   all observations of the given individuals are set to NA.
                   The value in SpName_codecor
      is 'more than one scientific name.`"
    )
  } else {
    text2 <- ""
  }
  text <- paste(text1, "\n", text2)
}
```

`r text`

### Only one set of coordinates per tree and no missing coordinates

```{=html}
<!-- Which coordinates do we take ? check if there are dataset with no absolute 
coordinate-->
```

### All trees within the plot

# Data visualization

We will now visualize the data to ensure there are no obvious outliers or unexpected trends

## DBH across plots and censuses

```{R dbh-visual}

# Mean DBH by Plot and Census Year
dbh_stats <- data_cor %>%
  group_by(Plot, Year) %>%
  summarise(mean_dbh = mean(Diameter, na.rm = TRUE),
            median_dbh = median(Diameter, na.rm = TRUE),
            min_dbh = min(Diameter, na.rm = TRUE),
            max_dbh = max(Diameter, na.rm = TRUE),
            .groups = "drop")

mean <- ggplot(dbh_stats, aes(x = Year, y = mean_dbh, 
                              color = as.factor(Plot))) +
  geom_line(show.legend = FALSE) +
  geom_point(show.legend = FALSE) +
  labs(title = "Mean DBH",
       x = "Census Year",
       y = "Mean DBH (cm)",
       color = "Plot") +
  theme_minimal()

median <- ggplot(dbh_stats, aes(x = Year, y = median_dbh, 
                              color = as.factor(Plot))) +
  geom_line(show.legend = FALSE) +
  geom_point(show.legend = FALSE) +
  labs(title = "Median DBH",
       x = "Census Year",
       y = "Median DBH (cm)",
       color = "Plot") +
  theme_minimal()

min <- ggplot(dbh_stats, aes(x = Year, y = min_dbh, 
                              color = as.factor(Plot))) +
  geom_line(show.legend = FALSE) +
  geom_point(show.legend = FALSE) +
  labs(title = "Minimum DBH",
       x = "Census Year",
       y = "Minimum DBH (cm)",
       color = "Plot") +
  theme_minimal()

max <- ggplot(dbh_stats, aes(x = Year, y = max_dbh, 
                              color = as.factor(Plot))) +
  geom_line(show.legend = FALSE) +
  geom_point(show.legend = FALSE) +
  labs(title = "Maximum DBH",
       x = "Census Year",
       y = "Maximum DBH (cm)",
       color = "Plot") +
  theme_minimal()

(min | max) / (mean | median)
```

## Number of species and genus across plots and censuses

```{r species-visual}

# Number of Species by Plot and Census Year

species_count <- data_cor %>%
  group_by(Plot, Year) %>%
  summarise(num_species = n_distinct(scientific_cleaned), .groups = "drop")

ggplot(species_count, aes(x = Year, y = num_species, 
                          colour = as.factor(Plot))) + 
  geom_line() +
  geom_point() +
  #geom_col(position = "dodge") +
  labs(title = "Number of Species by Plot and Census Year",
       x = "Census Year",
       y = "Species Count",
       fill = "Plot") +
  theme_minimal()

```

```{r genus-visual}

# Number of genus by Plot and Census Year

genus_count <- data_cor %>%
  group_by(Plot, Year) %>%
  summarise(num_genus = n_distinct(genus_cleaned), .groups = "drop")


ggplot(genus_count, aes(x = Year, y = num_genus, 
                          colour = as.factor(Plot))) + 
  geom_line() +
  geom_point() +
  #geom_col(position = "dodge") +
  labs(title = "Number of Genus by Plot and Census Year",
       x = "Census Year",
       y = "Genus Count",
       fill = "Plot") +
  theme_minimal()

```

## Visualizing plots and censuses

```{r maps-visual}

# Maps per plot and per census
map <- ggplot(data_cor, aes(x = longitude, y = latitude, color = as.factor(Plot))) +
  geom_point(alpha = 0.6, show.legend = FALSE) +
  #facet_wrap(~ Year) +
  labs(title = "Map of Plots by Census Year",
       x = "Longitude",
       y = "Latitude",
       color = "Plot ID") +
  theme_minimal()

plots <- ggplot(data_cor, aes(x = Year, y = Plot, color = as.factor(Plot))) +
  geom_point(alpha = 0.6, show.legend = FALSE) +
  #facet_wrap(~ Year) +
  labs(title = "Plots censused across years",
       x = "Longitude",
       y = "Latitude",
       color = "Plot ID") +
  theme_minimal()

(map / plots)



```

# DBH corrections

The following flowchart summarises the corrections applied to DBH and DBH changes. The steps (yellow rectangles) are explained and illustrated in each subsection.

![Flowchart of DBH corrections](flowchart_dbh_correction.png)

```{r create-diameter_cor}
data_cor$diameter_cor <- data_cor$Diameter
```

## Taper correction

Trees measured above the standard height of 1.3 m (e.g. if they have irregular trunks at 1.3 m due to buttresses) will have a smaller diameter measured than their actual DBH due to trunk taper. To correct for this systematic bias, taper corrections have been developed to estimate DBH based on the measured diameter and the height at which it was measured. 

```{r taper-correction}
taper_function <- function(diam, hom) {
  # default hom (no correction) when there is no reliable information
  hom[is.na(hom) | hom <= 0 | hom > 20] <- 1.3
  b <- exp(-2.0205 - 0.5053 * log(diam) + 0.3748 * log(hom))
  return(diam * exp(b * (hom - 1.3)))
}

if (params$taper) {
  if (any(colnames(data_cor) == "HOM")) {
    if (any(data_cor$HOM != 1.3)) {
      text <- paste(
        "The taper correction estimates DBH for diameter values measured above",
        "breast height. We used the function from function from Cushman et al.",
        "(2014): DBH = D.exp(b(HOM - 1.3)) where DBH is the estimated diameter",
        "at breast height, D is the measured diameter (cm) at height of",
        "measurement HOM (m) and b is defined as follows:\n",
        "b = exp(-2.0205 - 0.5053 ln(diam) + 0.3748 ln(HOM))."
      )
      # harmonize HOM values
      data_cor <- data_cor |>
        mutate(HOM = as.numeric(HOM)) |>
        # some values in cm: convert to m
        mutate(HOM = ifelse(HOM >= 50, HOM / 100, HOM)) |>
        # apply correction
        mutate(diameter_cor = taper_function(diameter_cor, HOM))

      subset(data_cor, HOM != 1.3) |>
        ggplot(aes(x = Diameter, y = diameter_cor, col = HOM)) +
        geom_abline(intercept = 0, slope = 1, lty = 2) +
        geom_point() +
        labs(
          x = "Original diameter (cm)",
          y = "Taper-corrected diameter (cm)"
        ) +
        scale_color_viridis_c() +
        theme_classic()
    } else {
      text <- paste(
        "All measurements were recorded as having been taken at HOM = 1.3 m,",
        "so we did not need to apply a taper correction."
      )
    }
  } else {
    text <- paste(
      "There is no information on height of measurement,",
      "so we could not apply any taper correction."
    )
  }
} else {
  text <- paste(
    "After testing various taper correction equations (Cushman et al. 2014, 2021), we found that these equations over-corrected the data at most sites and introduced a new bias. Until we find a taper correction that's better suited to Bioforest sites, we decided not to correct for taper."
  )
}
```

`r text`

## Interpolation of missing measurements

If trees are missed in a census and remeasured in a later census, we use the DBH values from the previous and next census to interpolate the missing DBH value(s).

This can lead to bias in the first and last censuses where missing DBH cannot be detected. We need to check that recruitment and mortality rates are not systematically lower in these two censuses.

```{r interpolate-missing-dbh}
interpolate <- function(diam, years) {
  if (sum(!is.na(diam)) > 1) {
    return(approx(years, diam, years)$y)
  } else {
    return(diam)
  }
}

# columns with tree-level information in data_cor
col_tree <-
  !grepl(
    "census|year|month|day|date|status|code|diam|hom|pom|circ|dbh",
    tolower(colnames(data_cor))
  )
col_pattern <- "Census|Year|Month|Day|Date|Status|Code|Diam|HOM|POM|Circ|DBH"

tree_info <- data_cor |>
  select(c("Year", colnames(data_cor)[col_tree])) |>
  group_by(Site, Plot, IdStem) |>
  filter(Year == max(Year)) |>
  select(-Year)

missing_censuses <- data_cor |>
  # list all census years by plot and subplot
  group_by(Site, Plot, Subplot) |>
  reframe(Year = unique(Year)) |>
  ungroup() |>
  # add all combinations of IdStem x IdCensus (by Plot and Subplot)
  merge(
    unique(data_cor[, c("Site", "Plot", "Subplot", "IdStem")]),
    by = c("Site", "Plot", "Subplot")
  ) |>
  # add tree-level information
  merge(tree_info) |>
  # add DBH information
  merge(
    data_cor[, c("IdStem", "Year", "diameter_cor")],
    by = c("IdStem", "Year"),
    all = TRUE
  ) |>
  # interpolate missing diameters
  group_by(IdStem) |>
  mutate(
    diameter_cor = interpolate(diameter_cor, Year)
  ) |>
  subset(!is.na(diameter_cor)) |>
  # keep only measurements missing from original data:
  subset(!paste(IdStem, Year) %in% with(data_cor, paste(IdStem, Year)))

# add interpolated DBHs to raw data
data_cor <- bind_rows(
  data_cor,
  missing_censuses
)
rm(missing_censuses)

if (sum(is.na(data_cor$Diameter)) > 0) {
  n_missing <- sum(is.na(data_cor$Diameter))
  stem_missing <- length(unique(data_cor$IdStem[is.na(data_cor$Diameter)]))
  text <- paste(
    "We found a total of", sum(is.na(data_cor$Diameter)),
    "missing DBH values, in", stem_missing, "stems.", 
    "The figure below shows a subset of", min(stem_missing, 12), 
    "trees with missing DBH (red points are interpolated DBH)."
  )
} else {
  text <- "No missing DBH values were interpolated."
}
```

`r text`

```{r fig-interpolate, fig.height=7, fig.width=11}
if (sum(is.na(data_cor$Diameter)) > 0) {
  illustration <- sample(
    subset(data_cor, is.na(Diameter))$IdStem,
    min(stem_missing, 12)
  )
  subset(data_cor, IdStem %in% illustration) |>
    separate(Plot, c(NA, "plot_label", NA), sep = "-", remove = FALSE) |> 
    mutate(label = paste0("Plot: ", plot_label, "_", Subplot, 
           ", treeID: ", IdTreeOriginal, "\n Species: ", scientific_cleaned)) |> 
    ggplot(aes(x = Year, y = diameter_cor)) +
    geom_point(aes(col = is.na(Diameter))) +
    labs(x = "Census year", y = "Diameter (cm)", col = "Interpolated") +
    scale_color_manual(values = c("black", "red")) +
    facet_wrap(~label, scales = "free") +
    theme_classic() +
    theme(legend.position = "bottom")
}
```

## Substitute excessive DBH changes

```{r}
before_bug <- data_cor
after_bug <- before_bug |>
  group_by(IdStem) |>
  arrange(Year, .by_group = TRUE) |>
  mutate(
    diam_growth = c(NA, diff(diameter_cor)) / c(NA, diff(Year)),
    diff_year = c(NA, diff(Year)),
    flag_negative = ifelse(diam_growth < 0, TRUE, FALSE)
  ) |>
  ungroup()
after_bug %>%
  group_by(IdStem) %>%
  summarise(n = sum(is.na(diam_growth))) %>%
  arrange(desc(n))
after_bug %>%
  filter(IdStem == "Paracou_10_1_120923_120923_1_auto") %>%
  select(Year, diam_growth)
```

```{r estimate-dbh-growth}
data_cor <- data_cor |>
  group_by(IdStem) |>
  arrange(Year, .by_group = TRUE) |>
  mutate(
    diam_growth = c(NA, diff(diameter_cor)) / c(NA, diff(Year)),
    diff_year = c(NA, diff(Year)),
    flag_negative = ifelse(diam_growth < 0, TRUE, FALSE)
  ) |>
  ungroup()

# TODO add dbh recruitment: standardize over previous census interval
```

### Define DBH change threshold

> proposal: use general threshold for lower bound, and moving 99th (or 95th) percentile for upper bound

DBH thresholds are defined by size class: trees DBH are split into 20 quantiles. The 99th DBH growth value per quantile is defined as the upper limit above with DBH growth values are considered outliers. The lower DBH growht limit is defined as the 1st percentile of DBH growth for all trees.

```{r dbh-change-thresholds}
data_cor <- data_cor |>
  ungroup() |>
  mutate(diam_quant = ntile(diameter_cor, 20)) |>
  mutate(dgrowth_lower = quantile(diam_growth, 0.01, na.rm = TRUE)) |>
  group_by(diam_quant) |>
  mutate(dgrowth_upper = quantile(diam_growth, 0.99, na.rm = TRUE)) |>
  mutate(outlier = diam_growth < dgrowth_lower | diam_growth > dgrowth_upper) |>
  mutate(average_growth = mean(diam_growth[!outlier], na.rm = TRUE)) |>
  ungroup() |>
  mutate(diam_growth_cor = ifelse(outlier, average_growth, diam_growth))

data_thresh <- data_cor |>
  group_by(diam_quant) |>
  summarise(
    diam_min = min(diameter_cor),
    diam_max = max(diameter_cor),
    dgrowth_upper = unique(dgrowth_upper),
    dgrowth_lower = unique(dgrowth_lower),
    average_growth = unique(average_growth)
  ) |>
  pivot_longer(cols = c("diam_max", "diam_min"))
data_cor |>
  subset(outlier) |>
  ggplot(aes(x = diameter_cor, y = diam_growth)) +
  geom_point() +
  geom_line(data = data_thresh, aes(x = value, y = dgrowth_upper), col = 2) +
  geom_line(data = data_thresh, aes(x = value, y = dgrowth_lower), col = 2) +
  geom_line(data = data_thresh, aes(x = value, y = average_growth), col = 4) +
  labs(x = "Diameter (cm)", y = "Diameter growth (cm/yr)") +
  scale_x_log10() +
  theme_classic()
```

This graph shows all outlier DBH growth values (in cm/yr), as well as the lower and upper bounds of "acceptable" DBH growth (in red) and the average DBH growth with which outlier values are replaced (blue), as a function of tree DBH.

### Shift DBH series

When there is a reported change in height of measurement but the new height of measurement is unknown.

```{r shift-dbh}
data_cor <- data_cor |>
  group_by(IdStem) |>
  mutate(
    hom_increase = c(NA, diff(HOM) > 0)
  )
# what column could have info on HOM change when no HOM value is available?
```

### Substitute excessive DBH changes

Outliers in DBH growth (but not DBHs) are replaced by the mean DBH growth of the corresponding size class (after excluding outlier values).

> Replacement by average DBH growth values is not optimal; it may introduce bias depending on the variable being estimated. For example, for AGB productivity it would be better to use average AGB.

`r with(data_cor, sum(diam_growth_cor != diam_growth & !is.na(diam_growth_cor)))` outlier DBH growth values were substituted. The following graph shows a subset of trees where the most DBH growth values were substituted.

```{r substitute-excessive-dbh-change}
id_cor <- subset(data_cor, outlier)$IdStem
tree_subs <-
  data_cor |>
  subset(IdStem %in% id_cor) |>
  group_by(IdStem) |>
  summarise(
    nsubs = sum(diam_growth_cor != diam_growth & !is.na(diam_growth_cor))
  ) |>
  arrange(desc(nsubs))

if (length(id_cor) > 0) {
  data_cor |>
    subset(IdStem %in% tree_subs$IdStem[1:6]) |>
    pivot_longer(cols = c("diam_growth", "diameter_cor")) |>
    ggplot(aes(x = Year)) +
    geom_point(aes(y = value, col = outlier)) +
    labs(col = "Outlier DBH growth?") +
    scale_color_manual(values = c("black", "red")) +
    facet_grid(name ~ IdStem, scales = "free") +
    theme_bw()
}
```

# Data aggregation

```{r create-data_aggr}
data_aggr <- c()
```

## Add census year information for flux calculation

```{r diff-year}
#| message: false
# for each census year, add information on previous and next census years
data_year <- data_cor |>
  ungroup() |>
  select(Site, Plot, Year) |>
  unique() |>
  arrange(Site, Plot, Year) |>
  group_by(Site, Plot) |>
  mutate(
    prev_census = c(NA, Year[-length(Year)]),
    next_census = c(Year[-1], NA)
  ) |>
  ungroup()

# add information on each tree's recruitment and mortality years
data_cor <- data_cor |>
  merge(data_year) |>
  mutate(recr_year = min(Year), mort_year = max(Year), .by = IdStem)
```

## Neutral diversity

```{r neutral-diversity}
# Calculate neutral diversity indices per plot and year

# species
neutral_div_sp <- data_cor %>%
  subset(!is.na(species_cleaned)) %>%
  group_by(Site, Plot, Year, scientific_cleaned) %>%
  summarise(count = n(), .groups = "drop") %>%
  group_by(Site, Plot, Year) %>%
  summarise(
    diversity_q0_sp = Diversity(count,
      q = 0, SampleCoverage = 0.8,
      Correction = "None"
    ),
    diversity_q1_sp = Diversity(count,
      q = 1, SampleCoverage = 0.8,
      Correction = "None"
    ),
    diversity_q2_sp = Diversity(count,
      q = 2, SampleCoverage = 0.8,
      Correction = "None"
    ),
    evenness_sp = Shannon(count, SampleCoverage = 0.8, Correction = "None") /
      log(n_distinct(scientific_cleaned)),
    coverage_sp = Coverage(count)
  ) %>%
  pivot_longer(
    cols = contains("_sp"),
    names_to = "variable",
    values_to = "value"
  )

# genera
neutral_div_gen <- data_cor %>%
  subset(!is.na(genus_cleaned)) %>%
  group_by(Site, Plot, Year, genus = genus_cleaned) %>%
  summarise(count = n(), .groups = "drop") %>%
  group_by(Site, Plot, Year) %>%
  summarise(
    diversity_q0_gen = Diversity(count,
      q = 0, SampleCoverage = 0.9,
      Correction = "None"
    ),
    diversity_q1_gen = Diversity(count,
      q = 1, SampleCoverage = 0.9,
      Correction = "None"
    ),
    diversity_q2_gen = Diversity(count,
      q = 2, SampleCoverage = 0.9,
      Correction = "None"
    ),
    evenness_gen = Shannon(count, SampleCoverage = 0.9, Correction = "None") /
      log(n_distinct(genus)),
    coverage_gen = Coverage(count)
  ) %>%
  pivot_longer(
    cols = contains("_gen"),
    names_to = "variable",
    values_to = "value"
  )

# Add to main dataframe with aggregatd data
data_aggr <- data_aggr %>%
  rbind(neutral_div_sp) %>%
  rbind(neutral_div_gen)

# Plot temporal trajectories of different indices across plots
data_aggr %>%
  subset(variable %in% neutral_div_sp$variable) %>%
  ggplot(aes(x = Year, y = value, color = as.factor(Plot))) +
  geom_line() +
  geom_point() +
  facet_wrap(~variable, scales = "free_y") +
  labs(
    title = "Diversity Indices Across Plots and Years - Species level",
    x = "Year", y = "Index Value", color = "Plot"
  ) +
  theme_minimal()

data_aggr %>%
  subset(variable %in% neutral_div_gen$variable) %>%
  ggplot(aes(x = Year, y = value, color = as.factor(Plot))) +
  geom_line() +
  geom_point() +
  facet_wrap(~variable, scales = "free_y") +
  labs(
    title = "Diversity Indices Across Plots and Years - Genus level",
    x = "Year", y = "Index Value", color = "Plot"
  ) +
  theme_minimal()
```

## Functional diversity and composition

### Functional composition

```{r functional-composition-ba}
data_aggr <- data_cor |>
  group_by(Site, Plot, Year, scientific_cleaned) |>
  reframe(ba = (diameter_cor / 200)^2 * pi) |>
  merge(
    read.delim("data/derived_data/traits_v4.tsv"),
    by = "scientific_cleaned"
  ) |>
  group_by(Site, Plot, Year, variable = paste0(trait, "_cwm_ba")) |>
  reframe(value = exp(weighted.mean(log(trait_value_imputed), ba))) |>
  rbind(data_aggr)
```

```{r functional-composition-n}
data_aggr <- data_cor |>
  group_by(Site, Plot, Year, scientific_cleaned) |>
  reframe(ba = (diameter_cor / 200)^2 * pi) |>
  merge(
    read.delim("data/derived_data/traits_v4.tsv"),
    by = "scientific_cleaned"
  ) |>
  group_by(Site, Plot, Year, variable = paste0(trait, "_cwm_n")) |>
  reframe(value = exp(mean(log(trait_value_imputed), na.rm = TRUE))) |>
  rbind(data_aggr)
```

```{r fig-functional-composition, fig.height=8, fig.width=12}
#| warning: false

var_names <- c(
  "LA_cwm_ba" = "Leaf area (mm2)",
  "N_cwm_ba" = "Leaf nitrogen content per leaf dry mass (mg g-1)",
  "SLA_cwm_ba" = "Specific leaf area (mm2 mg-1)",
  "WD_cwm_ba" = "Stem specific wood density (g cm-3)",
  "hmax_cwm_ba" = "Asymptotic height (m)"
)

data_aggr |>
  subset(grepl("_cwm_ba$", variable)) |>
  ggplot(aes(
    x = Year, y = value, color = factor(Plot),
    group = paste(Site, Plot)
  )) +
  geom_point() +
  geom_line() +
  labs(col = "Plot") +
  theme_minimal() +
  facet_wrap(~variable, scales = "free_y", labeller = as_labeller(var_names))
```

### Functional variance

```{r functional-var}
data_aggr <- data_cor |>
  group_by(Site, Plot, Year, scientific_cleaned) |>
  reframe(ba = (diameter_cor / 200)^2 * pi) |>
  merge(
    read.delim("data/derived_data/traits_v4.tsv"),
    by = "scientific_cleaned"
  ) |>
  group_by(Site, Plot, Year, variable = paste0(trait, "_cwv_n")) |>
  reframe(value = var(log(trait_value_imputed))) |>
  rbind(data_aggr)
```

```{r fig-functional-var, fig.height=8, fig.width=12}
#| warning: false

var_names <- c(
  "LA_cwv_n" = "Leaf area variance",
  "N_cwv_n" = "Leaf nitrogen content per leaf dry mass variance",
  "SLA_cwv_n" = "Specific leaf area variance",
  "WD_cwv_n" = "Stem specific wood density variance",
  "hmax_cwv_n" = "Asymptotic height variance"
)

data_aggr |>
  subset(grepl("_cwv_n$", variable)) |>
  ggplot(aes(
    x = Year, y = value, color = factor(Plot),
    group = paste(Site, Plot)
  )) +
  geom_point() +
  geom_line() +
  labs(col = "Plot") +
  theme_minimal() +
  facet_wrap(~variable, scales = "free_y", labeller = as_labeller(var_names))
```

### Functional diversity

```{r functional-div}
traits_used <- c("WD", "SLA", "LA", "N")
matrix_trait <- read.delim("data/derived_data/traits_v4.tsv") |>
  subset(scientific_cleaned %in% data_cor$scientific_cleaned) |>
  subset(trait %in% traits_used) |>
  mutate(log_trait_value_imputed = log(trait_value_imputed)) |>
  pivot_wider(
    id_cols = "scientific_cleaned",
    names_from = trait,
    values_from = log_trait_value_imputed
  ) |>
  column_to_rownames("scientific_cleaned") |>
  as.matrix()

matrix_abund <- data_cor %>%
  subset(!is.na(scientific_cleaned)) %>%
  group_by(
    meas_id = paste(Site, Plot, Year, sep = "__"),
    scientific_cleaned
  ) %>%
  summarise(count = n(), .groups = "drop") |>
  pivot_wider(
    id_cols = "meas_id",
    names_from = scientific_cleaned,
    values_from = count,
    values_fill = 0
  ) |>
  column_to_rownames("meas_id") |>
  as.matrix()

data_aggr <-
  fd_fric(matrix_trait, matrix_abund, stand = TRUE) |>
  merge(fd_fdiv(matrix_trait, matrix_abund)) |>
  merge(fd_feve(matrix_trait, matrix_abund)) |>
  merge(fd_fdis(matrix_trait, matrix_abund)) |>
  separate(site, c("Site", "Plot", "Year"), sep = "__") |>
  mutate(Year = as.numeric(Year)) |>
  pivot_longer(starts_with("F"), names_to = "variable") |>
  rbind(data_aggr)
```

We used the following log-transformed traits to compute functional diversity: `r traits_used`.

```{r fig-functional-div, fig.height=8, fig.width=12}
#| warning: false

var_names <- c(
  "FRic" = "Functional Richness (scaled)",
  "FDiv" = "Functional Divergence",
  "FEve" = "Functional Evenness",
  "FDis" = "Functional Dispersion"
)

data_aggr |>
  subset(grepl("^F", variable)) |>
  ggplot(aes(
    x = Year, y = value, color = factor(Plot),
    group = paste(Site, Plot)
  )) +
  geom_point() +
  geom_line() +
  labs(col = "Plot") +
  theme_minimal() +
  facet_wrap(~variable, scales = "free_y", labeller = as_labeller(var_names))
```

## Taxonomic (un)determination

```{r taxo-undet}
# add information on percentage of undetermined species
data_aggr <- data_cor |>
  group_by(Site, Plot, Year) |>
  summarise(
    p_undet_spp = sum(is.na(species_cleaned)) / n(),
    p_undet_gen = sum(is.na(genus_cleaned)) / n(),
  ) |>
  pivot_longer(starts_with("p_undet"), names_to = "variable") |>
  rbind(data_aggr)

data_aggr |>
  subset(grepl("p_undet", variable)) |>
  ggplot(aes(x = Year, y = value * 100, colour = factor(Plot))) +
  geom_line() +
  labs(y = "Undetermined stems (%)", colour = "Plot") +
  facet_wrap(~variable) +
  theme_minimal()
```

## Functional undetermination

```{r functional-undet}
data_aggr <- data_cor |>
  group_by(Site, Plot, Year, scientific_cleaned) |>
  reframe(ba = (diameter_cor / 200)^2 * pi) |>
  merge(
    read.delim("data/derived_data/traits_v4.tsv"),
    by = "scientific_cleaned"
  ) |>
  group_by(Site, Plot, Year, variable = paste0("p_imputed_", trait)) |>
  reframe(
    value = 1 - sum(!is.na(trait_value_raw)) / sum(!is.na(trait_value_imputed))
  ) |>
  rbind(data_aggr)
```

## Structural diversity

```{r gini-coef}
# as coded in package DescTools
gini <- function(x, w = NULL, unbiased = TRUE) {
  x <- x[!is.na(x)]
  if (is.null(w)) w <- rep(1, length(x))
  w <- w / sum(w)
  x <- x[id <- order(x)]
  w <- w[id]
  f_hat <- w / 2 + c(0, head(cumsum(w), -1))
  wm <- weighted.mean(x, w)
  res <- 2 / wm * sum(w * (x - wm) * (f_hat - weighted.mean(f_hat, w)))
  if (unbiased) {
    res <- res * 1 / (1 - sum(w^2))
  }
  return(res)
}

data_aggr <- data_cor |>
  group_by(Site, Plot, Year) |>
  summarise(variable = "gini", value = gini(diameter_cor)) |>
  rbind(data_aggr)
```

```{r dbh-mean}
data_aggr <- data_cor |>
  group_by(Site, Plot, Year) |>
  summarise(variable = "dbh_median", value = median(diameter_cor)) |>
  rbind(data_aggr)
```

```{r display-structural-div}
var_names <- c("gini" = "Gini coefficient", "dbh_median" = "Median DBH (cm)")

data_aggr |>
  subset(variable %in% c("gini", "dbh_median")) |>
  ggplot(aes(x = Year, y = value, color = factor(Plot))) +
  geom_point() +
  geom_line() +
  labs(col = "Plot") +
  theme_minimal() +
  facet_wrap(~variable, scales = "free_y", labeller = as_labeller(var_names))
```

## Stem abundance

```{r stem-abundance}
#| message: false
data_aggr <-
  data_cor |>
  group_by(Site, Plot, Year) |>
  summarise(
    nstem = n() / unique(PlotArea)
  ) |>
  pivot_longer(nstem, names_to = "variable") |>
  rbind(data_aggr)
```

```{r stem-recruitment}
#| message: false
data_aggr <- data_cor |>
  mutate(recr = ifelse(Year == recr_year, 1 / (Year - prev_census), 0)) |>
  group_by(Site, Plot, Year) |>
  summarise(nstem_recr = sum(recr / PlotArea)) |>
  pivot_longer(nstem_recr, names_to = "variable") |>
  rbind(data_aggr)
```

```{r stem-mort}
#| message: false
data_aggr <- data_cor |>
  subset(Year == mort_year) |>
  group_by(Site, Plot, Year, next_census) |>
  summarise(nstem_mort = sum(1 / (next_census - Year) / unique(PlotArea))) |>
  mutate(Year = next_census) |>
  subset(!is.na(Year)) |>
  ungroup() |>
  select(Site, Plot, Year, nstem_mort) |>
  pivot_longer(nstem_mort, names_to = "variable") |>
  rbind(data_aggr)
```

```{r plot-stem, fig.height=4, fig.width=12}
#| warning: false
var_names <- c(
  "nstem" = "Stem abundance (/ha)",
  "nstem_recr" = "Stem recruitment rate (/ha/yr)",
  "nstem_mort" = "Stem mortality rate (/ha/yr)"
)

data_aggr |>
  subset(grepl("nstem", variable)) |>
  ggplot(aes(x = Year, y = value, color = factor(Plot))) +
  geom_point() +
  geom_line() +
  labs(col = "Plot") +
  theme_minimal() +
  facet_wrap(~variable, scales = "free_y", labeller = as_labeller(var_names))
```

<!-- ```{r} -->

<!-- # TEMP check that diff and diff2 are the same: -->

<!-- data_aggr |> -->

<!--   subset(grepl("nstem", variable)) |>  -->

<!--   pivot_wider(names_from = variable) |>  -->

<!--   group_by(Site, Plot) |>  -->

<!--   arrange(Site, Plot, Year) |>  -->

<!--   mutate(diff = c(NA, (nstem[-1]-nstem[-length(nstem)])/diff(Year))) |>  -->

<!--   mutate(diff2 = nstem_recr-nstem_mort) |>  -->

<!--   subset(abs(diff-diff2)>1e-4) -->

<!-- ``` -->

## Basal area

```{r ba}
ba_func <- function(x) pi * (x / 200)**2
data_cor <- data_cor |>
  mutate(
    ba = ba_func(diameter_cor),
    ba_growth = ba_func(diameter_cor - diam_growth + diam_growth_cor) -
      ba_func(diameter_cor - diam_growth)
  )
```

```{r ba-stock}
#| message: false
data_aggr <-
  data_cor |>
  group_by(Site, Plot, Year) |>
  summarise(
    ba = sum(ba / PlotArea)
  ) |>
  pivot_longer(ba, names_to = "variable") |>
  rbind(data_aggr)
```

```{r ba-recr}
#| message: false
data_aggr <- data_cor |>
  # ba recruitment per tree
  mutate(recr = ifelse(Year == recr_year, ba / (Year - prev_census), 0)) |>
  group_by(Site, Plot, Year) |>
  summarise(ba_recr = sum(recr / PlotArea)) |>
  pivot_longer(ba_recr, names_to = "variable") |>
  rbind(data_aggr)
```

```{r ba-growth}
#| message: false
data_aggr <- data_cor |>
  subset(!is.na(ba_growth)) |>
  mutate(ba_gr_yr = ba_growth) |>
  group_by(Site, Plot, Year) |>
  summarise(ba_growth = sum(ba_gr_yr / PlotArea)) |>
  pivot_longer(ba_growth, names_to = "variable") |>
  rbind(data_aggr)
```

```{r ba-mort}
#| message: false
data_aggr <- data_cor |>
  subset(Year == mort_year) |>
  group_by(Site, Plot, Year, next_census) |>
  summarise(ba_mort = sum(ba / (next_census - Year) / PlotArea)) |>
  mutate(Year = next_census) |>
  subset(!is.na(Year)) |>
  select(Site, Plot, Year, ba_mort) |>
  pivot_longer(ba_mort, names_to = "variable") |>
  rbind(data_aggr)
```

```{r fig-ba, fig.height=8, fig.width=12}
#| warning: false
var_names <- c(
  "ba" = "Basal area (m2/ha)",
  "ba_recr" = "BA recruitment (m2/ha/yr)",
  "ba_growth" = "BA growth (m2/ha/yr)",
  "ba_mort" = "BA mortality (m2/ha/yr)"
)

data_aggr |>
  subset(grepl("^ba", variable)) |>
  ggplot(aes(
    x = Year, y = value, color = factor(Plot),
    group = paste(Site, Plot)
  )) +
  geom_point() +
  geom_line() +
  labs(col = "Plot") +
  theme_minimal() +
  facet_wrap(~variable, scales = "free_y", labeller = as_labeller(var_names))
```

## Aboveground biomass

We use equation 7 from Chave et al. (2014) to estimate tree-level aboveground biomass.

```{r add-wd}
# add wood density
data_cor <- read.delim("data/derived_data/traits_v4.tsv") |>
  subset(trait == "WD") |>
  pivot_wider(
    id_cols = "scientific_cleaned",
    names_from = trait,
    values_from = trait_value_imputed
  ) |>
  merge(data_cor, all.y = TRUE)

p_na_wd <- round(sum(is.na(data_cor$WD)) / nrow(data_cor) * 100, 1)
data_cor <- data_cor |>
  group_by(Site, Plot, Year) |>
  mutate(WD = ifelse(is.na(WD), mean(WD, na.rm = TRUE), WD)) %>%
  group_by(Site, Year) |>
  mutate(WD = ifelse(is.na(WD), mean(WD, na.rm = TRUE), WD)) %>%
  group_by(Site) |>
  mutate(WD = ifelse(is.na(WD), mean(WD, na.rm = TRUE), WD))

if (any(is.na(data_cor$WD))) {
  stop("NA in WD")
}
```

We used imputed specific wood density values; for individuals that were not identified to the species (`r p_na_wd`%), we use an average wood density value per plot and census year.

```{r agb}
agb_func <- function(d, wd, e_var) {
  return(exp(-2.023977 - 0.89563505 * e_var + 0.92023559 * log(wd) +
    2.79495823 * log(d) - 0.04606298 * (log(d)^2)) / 1000) # nolint
}
data_cor <- data_cor |>
  mutate(
    agb = agb_func(diameter_cor, WD, e),
    agb_growth = agb_func(diameter_cor - diam_growth + diam_growth_cor, WD, e) -
      agb_func(diameter_cor - diam_growth, WD, e)
  )
if (any(is.na(data_cor$agb))) {
  stop("NA in AGB values")
}
```

```{r agb-stocks}
#| message: false
data_aggr <-
  data_cor |>
  group_by(Site, Plot, Year) |>
  summarise(
    agb = sum(agb / PlotArea)
  ) |>
  pivot_longer(agb, names_to = "variable") |>
  rbind(data_aggr)
```

```{r agb-recr}
#| message: false
data_aggr <- data_cor |>
  # agb recruitment per tree
  mutate(recr = ifelse(Year == recr_year, agb / (Year - prev_census), 0)) |>
  group_by(Site, Plot, Year) |>
  summarise(agb_recr = sum(recr / PlotArea)) |>
  pivot_longer(agb_recr, names_to = "variable") |>
  rbind(data_aggr)
```

```{r agb_growth}
#| message: false
data_aggr <- data_cor |>
  subset(!is.na(agb_growth)) |>
  mutate(agb_gr_yr = agb_growth) |>
  group_by(Site, Plot, Year) |>
  summarise(agb_growth = sum(agb_gr_yr / PlotArea)) |>
  pivot_longer(agb_growth, names_to = "variable") |>
  rbind(data_aggr)
```

```{r agb-mort}
#| message: false
data_aggr <- data_cor |>
  subset(Year == mort_year) |>
  group_by(Site, Plot, Year, next_census) |>
  summarise(agb_mort = sum(agb / (next_census - Year) / PlotArea)) |>
  mutate(Year = next_census) |>
  subset(!is.na(Year)) |>
  select(Site, Plot, Year, agb_mort) |>
  pivot_longer(agb_mort, names_to = "variable") |>
  rbind(data_aggr)
```

```{r fig-agb, fig.height=8, fig.width=12}
#| warning: false
var_names <- c(
  "agb" = "AGB (t/ha)",
  "agb_recr" = "AGB recruitment (t/ha/yr)",
  "agb_growth" = "AGB growth (t/ha/yr)",
  "agb_mort" = "AGB mortality (t/ha/yr)"
)

data_aggr |>
  subset(grepl("agb", variable)) |>
  ggplot(aes(
    x = Year, y = value, color = factor(Plot),
    group = paste(Site, Plot)
  )) +
  geom_point() +
  geom_line() +
  labs(col = "Plot") +
  theme_minimal() +
  facet_wrap(~variable, scales = "free_y", labeller = as_labeller(var_names))
```

```{r save-aggregated-data}
data_aggr |>
  write.csv(paste0(
    "data/derived_data/aggregated_data_",
    paste(gsub(" ", "_", tolower(unique(data_aggr$Site))), collapse = "_"),
    ".csv"
  ), row.names = FALSE)
```


```{r save-plot-area}
data_cor |>
  select(Site, Plot, PlotArea) |>
  unique() |>
  write.csv(paste0(
    "data/derived_data/plot_area_",
    paste(gsub(" ", "_", tolower(unique(data_aggr$Site))), collapse = "_"),
    ".csv"
  ), row.names = FALSE)
```
