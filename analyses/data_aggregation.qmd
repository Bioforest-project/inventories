---
title: "Data aggregation"
format:
  pdf:
    toc: true
    number-sections: true
    colorlinks: true
execute:
  echo: false      
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
library(data.table)
library(BIOMASS)
library(ggplot2)
library(tidyverse)
```

<!-- TO DO
* check why the chucks are displayed despite the echo: false instruction.
-->

# Introduction

This document is made to be used by data contributors of the Bioforest project, which is an initiative of the TmFO network. By running this quarto document, you will be able to visualize various aspects of your data, and generate an aggregated data set as output. This aggregated data set (depending on the variables available) will be used for analysis by various working groups in the Bioforest project.

Before you run this quarto script, please make sure that you complete the following checklist, and ensure the your dataset is named and structured correctly to be able to run this script.

Checklist:

-   what is raw data? - uncorrected data

<!-- -->

-   sign the data agreement

-   harmonize your dataset

-   send species list (should already be ok)

-   add plot-level information in this [document](https://docs.google.com/spreadsheets/d/1fq2owxMBLBwwibcdw2uQQFxnIhsMbaH4Qcj_xUwVvSQ/edit?usp=drive_link)

<!-- Load the data -->

```{r load data}
# data_raw <- read.csv("data/raw_data/harmonized_data_bafog_v1.csv")
data_raw <- read.csv("data/raw_data/harmonized_data_mbaiki_v1.csv")
#### MITHILA, please leave this commented code here 
# while we are developping the code
# we will revove it later
```

# General presentation of the data

This document presents the data aggregation for the `r unique(data_raw$Site)`. This site had `r length(unique(data_raw$Plot))` plots: `r unique(data_raw$Plot)`.

It has `r dim(data_raw)[1]` observations, belonging to `r length(unique(data_raw$IdStem))` stems.

The following table shows the number of censuses per plots.

```{r censusNb}
data_raw %>%
  group_by(Plot) %>%
  summarise(census_number = length(unique(IdCensus))) %>%
  knitr::kable()
```

Censuses were conducted between `r min(data_raw$Year)` and `r max(data_raw$Year)`.

*Please add a comment on question XXXX of the survey, if there are missing plots or censuses.*

# Check data consistency

This step checks for the absence of "anomalies" in the data.

## No NA values in DBH

```{r Na_DBH}
if (anyNA(data_raw$Diameter)) {
  nb_na_dbh <- sum(is.na(data_raw$Diameter))
  perc_na_dbh <- round(
    sum(is.na(data_raw$Diameter)) * 100 / dim(data_raw)[1],
    2
  )
  text <- paste("There are",
    nb_na_dbh,
    "missing diameters in the data, which represent",
    perc_na_dbh,
    "% of the observations.
    The missing values are distributed across the plots and censuses as follow:.", # nolint
    sep = " "
  )
} else {
  text <- "There are no missing diameter in the data."
}
```

`r text`

```{r explo_na_DBH}
if (anyNA(data_raw$Diameter)) {
  data_raw %>%
    filter(is.na(Diameter)) %>%
    count(Plot, IdCensus) %>%
    pivot_wider(names_from = Plot, values_from = n) %>%
    knitr::kable()
}
```

## DBH cutoff

```{r DBHcutoff}
#| message: false
#| warning: false
if (length(unique(data_raw$MinDBH)) == 1) {
  text <- paste(
    "There is a single DBH cutoff set to",
    unique(data_raw$MinDBH),
    "cm for the whole data set."
  )
} else {
  # count the number of cutoff per plot and census
  cutoff_plot_cens <- data_raw %>%
    group_by(Plot, IdCensus) %>%
    summarise(cutoff = length(unique(MinDBH)))
  if (length(unique(cutoff_plot_cens$cutoff)) != 1) {
    text <- "There is more than one DBH cutoff per plot and per census.
    This is a problem, please check the data."
  } else {
    text <- "There are several DBH cutoff, as follow:"
  }
}
```

`r text`

```{r display_cutoff}
#| message: false
#| warning: false
if (length(unique(data_raw$MinDBH)) != 1) {
  if (length(unique(cutoff_plot_cens$cutoff)) == 1) {
    data_raw %>%
      group_by(Plot, IdCensus) %>%
      summarise(dbhcut = unique(MinDBH)) %>%
      pivot_wider(names_from = Plot, values_from = dbhcut) %>%
      knitr::kable()
  }
}
```

## All trees above the DBH cutoff

```{r abovecutoff}
below_cut <- data_raw %>%
  filter(Diameter < MinDBH) %>%
  select(MinDBH, IdCensus, Plot, Diameter)
if (dim(below_cut)[1] == 0) {
  text <- "There are no stems with a DBH below the DBH cutoff."
  data_cor <- data_raw
} else {
  below_cut <- below_cut %>%
    mutate(DBHDiff = MinDBH - Diameter)
  data_cor <- data_raw %>% filter(Diameter >= MinDBH)
  text <- paste("There are ",
    dim(below_cut)[1],
    " observations of stems with a DBH below the DBH cutoff (",
    round(dim(below_cut)[1] * 100 / dim(data_raw)[1], 1),
    "%). For these observations, the difference between
                the DBH and the cutoff ranges between ",
    round(min(below_cut$DBHDiff), 2), " cm and ",
    round(max(below_cut$DBHDiff), 2),
    " cm, with a median value of ",
    round(median(below_cut$DBHDiff), 2), "cm.
                These observations are removed, leaving a dataset of ",
    dim(data_cor)[1],
    " observations.",
    sep = ""
  )
}
```

`r text`

## No stem ID duplicates

```{r}
#| eval: false

# Make a dummy data set to test
dupl <- slice_sample(data_cor, n = 15) # some duplicated
dupl <- dupl %>%
  mutate(Diameter = replace(
    Diameter, IdStem == dupl$IdStem[1],
    dupl$Diameter[1] + 10
  )) # one duplicated with different DBH
data_cor <- rbind(data_cor, dupl)
data_cor <- rbind(data_cor, slice_sample(dupl, n = 3)) # some duplicated twice
data_cor %>%
  filter(IdStem == dupl$IdStem[2]) %>%
  slice_sample(, n = 2) -> dupl_sev_census # one IDstem with several duplicated censuses #nolint
data_cor <- rbind(data_cor, dupl_sev_census)
```

```{r nostemID_duplicate}
nb_stem_plot <- data_cor %>%
  count(IdStem, IdCensus)

if (all(length(unique(nb_stem_plot$n)) == 1, unique(nb_stem_plot$n) == 1)) {
  text <- "There is no duplicated stem identifiers within a same census."
} else {
  stem_dupli <- nb_stem_plot %>%
    filter(n > 1)
  text <- paste("There are ",
    dim(stem_dupli)[1],
    " cases of duplicated stem identifiers within a same census,",
    " with a number of duplications ranging from ",
    stem_dupli %>% summarise(min(n)),
    " and ",
    stem_dupli %>% summarise(max(n)),
    " (mean = ",
    stem_dupli %>% summarise(round(mean(n), 2)),
    "). These duplications concern ",
    length(unique(stem_dupli$IdStem)),
    " stems.",
    sep = ""
  )
}
```

`r text`

```{r rmv_full_duplicate}
if (length(unique(nb_stem_plot$n)) != 1) { # if there are some duplicates
  prev_nb_obs <- dim(data_cor)[1]
  data_cor <- data_cor %>% distinct() # remove fully duplicated rows
  if (prev_nb_obs - dim(data_cor)[1] != 0) { # if there were some fully duplicated rows #nolint
    text <- paste(
      prev_nb_obs - dim(data_cor)[1],
      "rows are true duplicates (fully identical rows).",
      "These true duplicates are removed from the dataset, leaving a dataset of ", # nolint
      dim(data_cor)[1],
      " observations."
    )
  } else {
    text <- ""
  }
  nb_stem_plot_bis <- data_cor %>%
    count(IdStem, IdCensus)
} else { # if no duplicated rows
  text <- ""
}
```

`r text`

```{r non_full_duplicates}
if (length(unique(nb_stem_plot$n)) != 1) { # if there are some duplicates
  if (all(
    length(unique(nb_stem_plot_bis$n)) == 1,
    unique(nb_stem_plot_bis$n) == 1
  )) {
    text <- "There is no more duplicated stem identifiers within a same census."
    still_stem_dupli <- FALSE
  } else {
    stem_dupli_bis <- nb_stem_plot_bis %>%
      filter(n > 1)
    text <- paste(
      "There are still",
      dim(stem_dupli_bis)[1],
      "cases of duplicated stem identifiers within a same census,",
      "which are not fully replicated rows.",
      "This concern the following cases:"
    )
    still_stem_dupli <- TRUE
  }
} else {
  still_stem_dupli <- FALSE
}
```

`r text`

```{r which_still_dupli}
if (still_stem_dupli == TRUE) {
  stem_dupli_bis %>% knitr::kable()
}
```

```{r warn_still_duplicate}
if (still_stem_dupli == TRUE) {
  text <- "IMPORTANT: Please check this cases in your raw data before starting the process again." # nolint
} else {
  text <- ""
}
```

`r text`

## Are there multi-stemmed trees?

```{r nbstemID}
if (length(unique(data_cor$IdStem)) == length(unique(data_cor$IdTree))) {
  text <- "The number of stem identifiers and the number of tree identifiers are equal, suggesting either that there are no multi-stemmed trees, or that the multiple stems are considered as different individuals." # nolint
} else {
  if (length(unique(data_cor$IdStem)) > length(unique(data_cor$IdTree))) {
    text <- "There are more stem identifiers than tree identifiers, suggesting that there are some multi-stemmed trees." # nolint
  } else {
    text <- "There are less stem identifiers than tree identifiers, which suggest a problem of duplicated stem identifiers." # nolint
  }
}
```

`r text`

## Only one species per tree

```{r uniquespeciespertree}
data_sps_dup <- data_raw %>%
  group_by(IdStem, ScientificName, Family, Genus, Species, VernName) %>%
  count() %>%
  add_count(IdStem, sort = FALSE, name = "freq_idstem") %>%
  filter(freq_idstem != 1)

if (dim(data_sps_dup)[1] == 0) {
  text <- "Every tree has the same name across all censuses, you can proceed to the next step" # nolint
} else {
  text <- c("There are still individuals to be check for their identification. They have a different species name in different censuses. Please check the following table to identify the individuals that are not consistently named:", data_sps_dup) # nolint
}
```

`r text`

## Only one set of coordinates per tree and no missing coordinates

<!-- Which coordinates do we take ? check if there are dataset with no absolute coordinate-->

## All trees within the plot

# First step of data visualization

-   stem abundance by plot and census year

-   mean (or median) dbh by plot and census year

-   number of species

-   maps per plot and per census

# DBH corrections

![Flowchart of DBH corrections](flowchart_dbh_correction.png)

```{r}
data_raw$DiameterCor <- data_raw$Diameter
```

## Taper correction

```{r}
source("r/taper.R")
if (any(colnames(data_raw) == "HOM")) {
  text <- paste(
    "The height of measurement information is available so we could apply the",
    "taper correction from Cushman et al., 2014."
  )
  data_raw$DiameterCor <- taper(data_raw$DiameterCor, data_raw$HOM)
  subset(data_raw, HOM > 1.3) |>
    ggplot(aes(x = Diameter, y = DiameterCor, col = HOM)) +
    geom_abline(intercept = 0, slope = 1, lty = 2) +
    geom_point() +
    labs(x = "Original diameter (cm)", y = "Taper-corrected diameter (cm)") +
    scale_color_viridis_c() +
    theme_classic()
} else {
  text <- paste(
    "There is no information on height of measurement information,",
    "so we could not apply any taper correction."
  )
}
```

`r text`

## Interpolating missing measurements

```{r}
source("r/interpolate.R")
missing_censuses <- data_raw |>
  # list all census years by plot and subplot
  group_by(Plot, Subplot) |>
  reframe(Year = unique(Year)) |>
  ungroup() |>
  # add all combinations of IdTree x IdCensus (by Plot and Subplot)
  merge(
    unique(data_raw[, c("Plot", "Subplot", "IdTree")]),
    by = c("Plot", "Subplot")
  ) |>
  # add DBH information
  merge(
    data_raw[, c("IdTree", "Year", "DiameterCor")],
    by = c("IdTree", "Year"),
    all = TRUE
  ) |>
  # interpolate missing diameters
  group_by(IdTree) |>
  reframe(
    Year = Year,
    DiameterCor = interpolate(DiameterCor, Year)
  ) |>
  subset(!is.na(DiameterCor))

# add tree-level information
col_tree <-
  !grepl(
    "census|year|month|day|date|status|code|diam|hom|pom|circ|dbh",
    tolower(colnames(data_raw))
  )
missing_censuses <- merge(missing_censuses,
  unique(data_raw[, col_tree]),
  by = "IdTree"
)

# add interpolated DBHs to raw data
data_raw <- merge(
  data_raw,
  missing_censuses,
  all.y = TRUE
)
rm(missing_censuses)

if (sum(is.na(data_raw$Diameter)) > 0) {
  text <- paste(
    sum(is.na(data_raw$Diameter)),
    "missing DBH values were interpolated."
  )
  illustration <- sample(subset(data_raw, is.na(Diameter))$IdTree, 12)
  subset(data_raw, IdTree %in% illustration) |>
    ggplot(aes(x = Year, y = DiameterCor)) +
    geom_point(aes(col = is.na(Diameter))) +
    labs(x = "Census year", y = "Diameter (cm)", col = "Interpolated") +
    scale_color_manual(values = c("black", "red")) +
    facet_wrap(~IdTree, scales = "free") +
    theme_classic() +
    theme(legend.position = "bottom")
} else {
  text <- "No missing DBH values were interpolated."
}
```

`r text`

## Correct DBH changes

### Estimate DBH changes

### Define DBH change threshold

### Shift DBH series

When there is a reported change in height of measurement but the new height of measurement is unknown.

### Substitute excessive DBH changes

# Biodiversity metrics

# Aboveground biomass
